﻿<!DOCTYPE html>
<html lang="nl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Sequencer – Samples + FX + Hold + MIDI Import + MIDI OUT + Save/Load JSON + WAV Export</title>
    <style>
      :root { --cellW: 92px; --cellH: 38px; --stepW: 64px; }
      html, body { margin:0; padding:0; height:100%; background:#fff; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; }

      .topbar{
        position:sticky; top:0; z-index:1000;
        background:#fff; border-bottom:1px solid rgba(0,0,0,.12);
        padding:12px 14px; display:flex; gap:10px; align-items:center; flex-wrap:wrap;
      }
      .btn{
        padding:10px 14px; border-radius:8px;
        border:1px solid rgba(0,0,0,.2);
        background:#f6f6f6; font-weight:800; cursor:pointer;
      }
      .btn:active{ transform:translateY(1px); }
      .btn.play{ background:#e9ffe9; }
      .btn.stop{ background:#ffe9e9; }
      .btn.midi{ background:#fff3e6; }
      .btn.wav{ background:#eef6ff; }

      .bpmBox{ display:flex; align-items:center; gap:10px; }
      #bpmSlider{ width:220px; }
      .numBox{
        height:38px; width:120px;
        border-radius:8px; border:1px solid rgba(0,0,0,.2);
        padding:0 10px; font-weight:900;
        font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
      }

      .inlineSelect{
        height:38px; border-radius:8px;
        border:1px solid rgba(0,0,0,.2);
        padding:0 10px; font-weight:800; background:#fff;
      }
      .inlineLabel{ font-weight:900; opacity:.85; font-size:12px; margin-left:6px; margin-right:-6px; }

      .fileNameInput{
        height:38px; border-radius:8px; border:1px solid rgba(0,0,0,.2);
        padding:0 10px; min-width:220px; font-weight:800;
      }

      .status{
        margin-left:0; font-size:12px; opacity:.75;
        font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
      }

      input[type="file"]{ display:none; }

      .errorBox{
        display:none; margin:10px 14px 0; padding:10px 12px;
        border-radius:10px; border:1px solid rgba(255,0,0,.35);
        background:rgba(255,0,0,.06); color:#7a0000;
        white-space:pre-wrap;
        font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
      }

      .wrap{ padding:10px 14px 18px; }
      #SEQUENCER{ margin-top:8px; }

      .row{ display:flex; align-items:center; border-left:3px solid transparent; padding:2px 0; }
      .row.active{ background:rgba(0,0,0,.04); border-left-color:#000; }

      .stepIndex{
        width:var(--stepW); flex:0 0 var(--stepW);
        text-align:center; cursor:pointer; user-select:none;
        font-size:12px; opacity:.85;
        font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
      }
      .stepIndex:hover{ text-decoration:underline; opacity:1; }

      .cellWrap{
        width:var(--cellW); flex:0 0 var(--cellW);
        height:var(--cellH);
        border-radius:8px; border:1px solid rgba(0,0,0,.2);
        background:#fff; display:flex; overflow:hidden; position:relative;
      }
      .cellMain{ flex:1 1 auto; border:none; background:transparent; cursor:pointer; }
      .cellHandle{
        width:28%;
        border:none; border-left:1px solid rgba(0,0,0,.18);
        background:rgba(0,0,0,.04);
        cursor:pointer; font-size:14px; font-weight:900; opacity:.85;
      }
      .cellHandle:hover{ background:rgba(0,0,0,.07); }
      .cellWrap.selected{ background:#1e6fff; }
      .cellWrap.selected .cellHandle{
        background:rgba(255,255,255,.2);
        border-left:1px solid rgba(255,255,255,.22);
        color:#fff; opacity:1;
      }
      .cellWrap.activeNote{ background:yellow !important; border:2px solid green; }

      /* Dropdown */
      #DROPDOWN{
        position:fixed; display:none; z-index:2000;
        width:520px; max-height:80vh; overflow:auto;
        background:#fff; border-radius:12px;
        border:1px solid rgba(0,0,0,.18);
        box-shadow:0 10px 24px rgba(0,0,0,.18);
        padding:12px;
      }
      .ddTop{ display:flex; justify-content:space-between; gap:10px; align-items:flex-start; margin-bottom:8px; }
      .ddTitle{ margin:0; font-size:14px; font-weight:900; }
      .ddSub{
        margin-top:4px; font-size:12px; opacity:.7;
        font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
      }
      .ddClose{
        border:1px solid rgba(0,0,0,.2); background:#f6f6f6;
        border-radius:10px; padding:6px 10px;
        cursor:pointer; font-weight:900;
      }
      details.menu{
        border:1px solid rgba(0,0,0,.15);
        border-radius:12px; padding:8px 10px; margin-top:10px;
      }
      details.menu > summary{ cursor:pointer; font-weight:900; list-style:none; }
      details.menu > summary::-webkit-details-marker{ display:none; }
      .gridMini{ margin-top:8px; display:grid; gap:8px; }
      .miniRow{ display:grid; grid-template-columns:1fr 1fr; gap:8px; align-items:center; }
      .miniRow label{ font-size:12px; opacity:.75; }
      .miniRow input,.miniRow select{
        height:32px; border-radius:10px;
        border:1px solid rgba(0,0,0,.2);
        padding:2px 10px; font-size:13px; width:100%; box-sizing:border-box;
      }
      .toggleRow{ display:flex; align-items:center; gap:10px; padding:6px 0 0; }
      .toggleRow label{ font-size:12px; font-weight:900; opacity:.85; }
      .toggleRow input{ transform:scale(1.15); }

      .freqSlider{ width:100%; }
      .helpTiny{
        font-size:11px;
        opacity:.7;
        margin-top:6px;
        line-height:1.25;
      }

      .miniBtn{
        height:32px;
        border-radius:10px;
        border:1px solid rgba(0,0,0,.2);
        background:#f6f6f6;
        font-weight:900;
        cursor:pointer;
      }
      .miniBtn:active{ transform:translateY(1px); }
    </style>
  </head>

  <body>
    <div class="topbar">
      <button id="play" class="btn play">PLAY</button>
      <button id="stop" class="btn stop">STOP</button>

      <div class="bpmBox">
        <b>BPM</b>
        <input id="bpmSlider" type="range" min="1" max="240" step="0.01" />
        <input id="bpmInput" class="numBox" type="number" min="1" max="240" step="0.01" />
      </div>


<label style="display:flex;align-items:center;gap:8px;font-weight:900;">
  <input id="adsrToggle" type="checkbox" />
  ADSR
  <span style="font-weight:900;">Scale</span>
<input id="adsrScale" type="range" min="0.1" max="4" step="0.1" value="1" style="width:140px;" />
<span id="adsrScaleVal" style="min-width:3ch;text-align:right;font-weight:900;">1.0</span></label>


<label style="display:flex;align-items:center;gap:8px;font-weight:900;">
  <input id="glideToggle" type="checkbox" />
  Glide
  <span style="font-weight:900;">Time</span>
  <input id="glideTime" type="range" min="0.00" max="0.60" step="0.01" value="0.18" style="width:140px;" />
  <span id="glideTimeVal" style="min-width:4ch;text-align:right;font-weight:900;">0.18s</span>
  <span style="font-weight:900;margin-left:10px;">Overlap</span>
  <input id="overlapRatio" type="range" min="0" max="1.5" step="0.05" value="0.35" style="width:120px;" />
  <span id="overlapRatioVal" style="min-width:4ch;text-align:right;font-weight:900;">0.35</span>
</label>


<button id="shuffle" class="btn">Shuffle</button>
      <button id="scale10100" class="btn">20-100 Hz</button>
      <button id="shuffleHiVibPanRev" class="btn">Shuffle 1k-20k VibPanRev</button>
      <button id="shuffleSample10" class="btn">Shuffle Sample (10%)</button>
      <input id="shuffleSampleFile" type="file" accept="audio/*,.wav,.mp3,.ogg,.m4a,.flac" multiple webkitdirectory />

      <span class="inlineLabel">Notes/line</span>
      <select id="notesPerLine" class="inlineSelect" disabled title="Vast: 10">
        <option value="8">8</option>
        <option value="10" selected>10</option>
        <option value="13">13</option>
        <option value="16">16</option>
        <option value="20">20</option>
      </select>

      <span class="inlineLabel">MIDI OUT</span>
      <select id="midiOutSelect" class="inlineSelect">
        <option value="">(geen)</option>
      </select>
      <button id="midiRefresh" class="btn midi">MIDI refresh</button>

      <span class="inlineLabel">Send mode</span>
      <select id="midiSendMode" class="inlineSelect">
        <option value="per_cell" selected>per cell</option>
        <option value="override">override channel</option>
        <option value="all">all channels</option>
      </select>

      <select id="midiOverrideCh" class="inlineSelect" title="Override channel (1..16)">
        <option value="1">ch 1</option><option value="2">ch 2</option><option value="3">ch 3</option><option value="4">ch 4</option>
        <option value="5">ch 5</option><option value="6">ch 6</option><option value="7">ch 7</option><option value="8">ch 8</option>
        <option value="9">ch 9</option><option value="10">ch 10</option><option value="11">ch 11</option><option value="12">ch 12</option>
        <option value="13">ch 13</option><option value="14">ch 14</option><option value="15">ch 15</option><option value="16">ch 16</option>
      </select>

      <button id="midiLoadBtn" class="btn midi">Load MIDI</button>
      <input id="midiFileInput" type="file"
        accept=".mid,.midi,audio/midi,audio/mid,application/x-midi,application/octet-stream,*/*" />

      <button id="s2mLoadSampleBtn" class="btn midi" title="Selecteer een audio sample (wordt onthouden)">Load Sample</button>
      <button id="s2mLoadMidiBtn" class="btn midi" title="Selecteer een MIDI bestand en pas de geladen sample toe">Apply sample to loaded MIDI</button>
      <input id="midiSampleAudioInput" type="file" accept="audio/*" style="position:fixed;left:-10000px;top:0;opacity:0;width:1px;height:1px;" />
      <input id="midiSampleMidiInput" type="file" accept=".mid,.midi,audio/midi,audio/mid,application/x-midi,application/octet-stream,*/*" style="position:fixed;left:-10000px;top:0;opacity:0;width:1px;height:1px;" />
      <span class="inlineLabel">Root</span>
      <input id="midiSampleRoot" class="miniNum" type="number" min="0" max="127" step="1" value="60" title="Root note (MIDI) voor sample pitch (60=C4)" />

      <span class="inlineLabel">JSON</span>
      <input id="fileName" class="fileNameInput" type="text" value="sequencer-state" />
      <button id="saveJson" class="btn">Save JSON</button>
      <button id="loadJson" class="btn">Load JSON</button>
      <button id="resetAll" class="btn">Reset</button>
      <input id="jsonFileInput" type="file" accept="application/json,.json" />

      <button id="exportWav" class="btn wav">Export WAV</button>
      <button id="exportWavBpm" class="btn wav">Export WAV (current BPM)</button>
      <button id="recordLiveWav" class="btn wav">Record LIVE WAV</button>

            <button id="recordLiveVideo" class="btn wav" title="Neem een zwart-wit frequentiebeeld + audio op als video (real-time)">Export LIVE VIDEO</button>
            <label style="display:inline-flex;align-items:center;gap:6px;margin-left:8px;user-select:none;">
              <input id="videoFxPreview" type="checkbox" />
              <span class="inlineLabel" style="margin:0;">Preview VIDEO audio</span>
            </label>

      <div id="algoUi" style="margin-left:auto;display:flex;gap:10px;align-items:center;flex-wrap:wrap;">
        <span class="inlineLabel">Algo</span>
        <select id="algoSelect" class="inlineSelect" title="MIDI generator algoritme"></select>

        <span class="inlineLabel">Length (ms)</span>
        <input id="algoLengthMs" class="numBox" type="number" min="10" step="1" value="30000" style="width:140px;" />

        <span class="inlineLabel">Variations</span>
        <input id="algoVar" type="range" min="0" max="1" step="0.01" value="0.35" style="width:140px;" />
        <span id="algoVarVal" style="min-width:4ch;text-align:right;font-weight:900;">0.35</span>

        <button id="algoDownloadMidi" class="btn midi" title="Genereer MIDI met gekozen algoritme">Download MIDI</button>
        <div class="gridMini" style="margin-top:10px;">
          <div class="miniRow">
            <label style="font-weight:900;">Master FX chain (4 slots)</label>
            <div class="helpTiny" style="margin-left:auto;">Globaal: slot1 → slot2 → slot3 → slot4 (live + LIVE VIDEO audio)</div>
          </div>

          <div class="miniRow"><label>Slot 1</label><select id="masterFXType1" style="flex:1;"></select></div>
          <div class="miniRow"><label>A1</label><input id="masterFX1_1" type="range" min="0" max="1" step="0.01" style="flex:1;" /><span id="masterFX1Val_1" class="tinyVal" style="min-width:4ch;text-align:right;">0.25</span></div>
          <div class="miniRow"><label>B1</label><input id="masterFX2_1" type="range" min="0" max="1" step="0.01" style="flex:1;" /><span id="masterFX2Val_1" class="tinyVal" style="min-width:4ch;text-align:right;">0.25</span></div>

          <div class="miniRow"><label>Slot 2</label><select id="masterFXType2" style="flex:1;"></select></div>
          <div class="miniRow"><label>A2</label><input id="masterFX1_2" type="range" min="0" max="1" step="0.01" style="flex:1;" /><span id="masterFX1Val_2" class="tinyVal" style="min-width:4ch;text-align:right;">0.25</span></div>
          <div class="miniRow"><label>B2</label><input id="masterFX2_2" type="range" min="0" max="1" step="0.01" style="flex:1;" /><span id="masterFX2Val_2" class="tinyVal" style="min-width:4ch;text-align:right;">0.25</span></div>

          <div class="miniRow"><label>Slot 3</label><select id="masterFXType3" style="flex:1;"></select></div>
          <div class="miniRow"><label>A3</label><input id="masterFX1_3" type="range" min="0" max="1" step="0.01" style="flex:1;" /><span id="masterFX1Val_3" class="tinyVal" style="min-width:4ch;text-align:right;">0.25</span></div>
          <div class="miniRow"><label>B3</label><input id="masterFX2_3" type="range" min="0" max="1" step="0.01" style="flex:1;" /><span id="masterFX2Val_3" class="tinyVal" style="min-width:4ch;text-align:right;">0.25</span></div>

          <div class="miniRow"><label>Slot 4</label><select id="masterFXType4" style="flex:1;"></select></div>
          <div class="miniRow"><label>A4</label><input id="masterFX1_4" type="range" min="0" max="1" step="0.01" style="flex:1;" /><span id="masterFX1Val_4" class="tinyVal" style="min-width:4ch;text-align:right;">0.25</span></div>
          <div class="miniRow"><label>B4</label><input id="masterFX2_4" type="range" min="0" max="1" step="0.01" style="flex:1;" /><span id="masterFX2Val_4" class="tinyVal" style="min-width:4ch;text-align:right;">0.25</span></div>
        </div>
<span id="status" class="status"></span>
    </div>

    
    <div id="EXPORT_OVERLAY" style="position:fixed;inset:0;display:none;z-index:9999;background:rgba(0,0,0,.35);align-items:flex-start;justify-content:flex-start;padding:16px;box-sizing:border-box;">
      <div style="background:#fff;border-radius:14px;padding:12px 14px;max-width:520px;width:100%;border:1px solid rgba(0,0,0,.2);box-shadow:0 10px 30px rgba(0,0,0,.25);">
        <div style="font-weight:900;margin-bottom:6px;">WAV export</div>
        <div id="EXPORT_MSG" style="font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,'Liberation Mono','Courier New',monospace;font-size:12px;opacity:.85;white-space:pre-wrap;"></div>
        <div style="margin-top:10px;display:flex;gap:10px;align-items:center;">
          <div style="flex:1;height:10px;background:rgba(0,0,0,.08);border-radius:999px;overflow:hidden;">
            <div id="EXPORT_BAR" style="height:10px;width:0%;background:#1e6fff;"></div>
          </div>
          <button id="EXPORT_CANCEL" class="btn" type="button">Cancel</button>
        </div>
      </div>
    </div>

    <div id="ERROR" class="errorBox"></div>

    <div class="wrap">
      <div id="SEQUENCER"></div>
    </div>

    <!-- Dropdown -->
    <div id="DROPDOWN" aria-hidden="true">
      <div class="ddTop">
        <div>
          <h3 class="ddTitle">Step instellingen</h3>
          <div id="ddSub" class="ddSub"></div>
        </div>
        <button id="ddClose" class="ddClose">X</button>
      </div>

      <details class="menu" open>
        <summary>Step</summary>
        <div class="gridMini">
          <div class="toggleRow">
            <input id="uiHold" type="checkbox" />
            <label for="uiHold">Step verlaten (sustain door)</label>
          </div>
          <div class="helpTiny">
            Als dit aan staat, wordt de noot niet automatisch losgelaten aan het eind van deze step.
            De noot stopt pas als de cel later uit staat (of bij STOP).
          </div>
        </div>
      </details>

      <details class="menu" open>
        <summary>Sound</summary>
        <div class="gridMini">
          <div class="miniRow">
            <label>Hz (nummer)</label>
            <input id="uiFreq" type="number" min="1" max="10000" step="0.01" />
          </div>

          <div class="miniRow">
            <label>Hz (slider)</label>
            <input id="uiFreqSlider" class="freqSlider" type="range" min="1" max="10000" step="1" />
          </div>

          <div class="miniRow">
            <label>Wave</label>
            <select id="uiWave">
              <option value="sine">sine</option>
              <option value="triangle">triangle</option>
              <option value="sawtooth">sawtooth</option>
              <option value="square">square</option>
            </select>
          </div>

          <div class="miniRow">
            <label>Source</label>
            <select id="uiSource">
              <option value="osc">osc</option>
              <option value="sample">sample</option>
            </select>
          </div>

          <div class="miniRow">
            <label>Load sample</label>
            <button id="uiLoadSample" class="miniBtn" type="button">Load audio file</button>
          </div>
          <div class="miniRow">
            <label>Sample start (%)</label>
            <input id="uiSampleStart" type="number" min="0" max="100" step="0.01" />
          </div>
          <div class="miniRow">
            <label>Sample length (%)</label>
            <input id="uiSampleLen" type="number" min="0.01" max="100" step="0.01" />
          </div>


          <div class="helpTiny">
            Sample speelt met ADSR + FX. Kies "sample" als source om de sample te gebruiken.
          </div>
        </div>
      </details>

      <details class="menu" open>
        <summary>ADSR</summary>
        <div class="gridMini">
          <div class="miniRow"><label>Attack (s)</label><input id="uiA" type="number" min="0" step="0.001" /></div>
          <div class="miniRow"><label>Decay (s)</label><input id="uiD" type="number" min="0" step="0.001" /></div>
          <div class="miniRow"><label>Sustain (0..10)</label><input id="uiS" type="number" min="0" step="0.01" /></div>
          <div class="miniRow"><label>Release (s)</label><input id="uiR" type="number" min="0" step="0.001" /></div>
        </div>
      </details>

      <details class="menu" open style="display:none;">
        <summary>Effect (15)</summary>
        <div class="gridMini">
          <div class="miniRow"><label>Type</label><select id="uiFXType"></select></div>
          <div class="miniRow"><label>Param 1</label><input id="uiFX1" type="number" step="0.01" /></div>
          <div class="miniRow"><label>Param 2</label><input id="uiFX2" type="number" step="0.01" /></div>

          <div class="miniRow">
            <label>FX audition</label>
            <div style="display:flex; gap:8px;">
              <button id="uiFXDryHold" class="miniBtn" type="button" style="flex:1;">Hold: DRY</button>
              <button id="uiFXWetHold" class="miniBtn" type="button" style="flex:1;">Hold: WET</button>
            </div>
          </div>

          <div class="helpTiny">
            <b>DRY</b> = zonder FX. <b>WET</b> = met FX. Houd ingedrukt om te luisteren.
          </div>
        </div>
      </details>

      <details class="menu" open>
        <summary>MIDI (per step)</summary>
        <div class="gridMini">
          <div class="toggleRow">
            <input id="uiMidiEnable" type="checkbox" />
            <label for="uiMidiEnable">Enable MIDI for this step</label>
          </div>

          <div class="miniRow">
            <label>Channel (1..16)</label>
            <input id="uiMidiCh" type="number" min="1" max="16" step="1" />
          </div>

          <div class="miniRow">
            <label>Command</label>
            <select id="uiMidiCmd">
              <option value="note">Note</option>
              <option value="cc">CC</option>
              <option value="program">Program</option>
              <option value="pitchbend">PitchBend</option>
            </select>
          </div>

          <div class="miniRow" id="rowMidiNote">
            <label>Note # (0..127)</label>
            <input id="uiMidiNote" type="number" min="0" max="127" step="1" />
          </div>

          <div class="miniRow" id="rowMidiVel">
            <label>Velocity (0..127)</label>
            <input id="uiMidiVel" type="number" min="0" max="127" step="1" />
          </div>

          <div class="miniRow" id="rowMidiCCN" style="display:none;">
            <label>CC # (0..127)</label>
            <input id="uiMidiCCN" type="number" min="0" max="127" step="1" />
          </div>
          <div class="miniRow" id="rowMidiCCV" style="display:none;">
            <label>CC value (0..127)</label>
            <input id="uiMidiCCV" type="number" min="0" max="127" step="1" />
          </div>

          <div class="miniRow" id="rowMidiProg" style="display:none;">
            <label>Program (0..127)</label>
            <input id="uiMidiProg" type="number" min="0" max="127" step="1" />
          </div>

          <div class="miniRow" id="rowMidiPB" style="display:none;">
            <label>PitchBend (-8192..8191)</label>
            <input id="uiMidiPB" type="number" min="-8192" max="8191" step="1" />
          </div>
        </div>
      </details>

      <details class="menu" open>
        <summary>Preview</summary>
        <div class="gridMini">
          <div class="miniRow">
            <label>Hold to preview</label>
            <button id="uiPreviewHold" class="miniBtn" type="button">Hold</button>
          </div>
          <div class="helpTiny">
            Houd ingedrukt om de geselecteerde step te luisteren. (ESC stopt ook.)
          </div>
        </div>
      </details>

      <input id="hiddenSampleFile" type="file" accept="audio/*" />
    </div>

    <script>
      (() => {
        // ---------- error/status ----------
        const ERROR = document.getElementById("ERROR");
        const STATUS = document.getElementById("status");
        function setStatus(msg){
          STATUS.textContent = msg || "";
          if(msg) setTimeout(()=>{ if(STATUS.textContent===msg) STATUS.textContent=""; }, 1600);
        }
        function showError(err){
          ERROR.style.display = "block";
          ERROR.textContent = "JS error:\n" + (err && err.stack ? err.stack : String(err));
        }
        window.addEventListener("error", (e)=> showError(e.error || e.message));
        window.addEventListener("unhandledrejection", (e)=> showError(e.reason));

// ---------- export overlay ----------
const EXPORT_OVERLAY = document.getElementById("EXPORT_OVERLAY");
const EXPORT_MSG = document.getElementById("EXPORT_MSG");
const EXPORT_BAR = document.getElementById("EXPORT_BAR");
const EXPORT_CANCEL = document.getElementById("EXPORT_CANCEL");
let exportCancelRequested = false;

function exportShow(msg, pct){
  if(!EXPORT_OVERLAY) return;
  EXPORT_OVERLAY.style.display = "flex";
  if(EXPORT_MSG) EXPORT_MSG.textContent = msg || "";
  if(EXPORT_BAR && typeof pct === "number"){
    const p = Math.max(0, Math.min(100, pct));
    EXPORT_BAR.style.width = p.toFixed(1) + "%";
  }
}
function exportHide(){
  if(!EXPORT_OVERLAY) return;
  EXPORT_OVERLAY.style.display = "none";
  if(EXPORT_BAR) EXPORT_BAR.style.width = "0%";
  if(EXPORT_MSG) EXPORT_MSG.textContent = "";
}
if(EXPORT_CANCEL){
  EXPORT_CANCEL.addEventListener("click", ()=>{
    exportCancelRequested = true;
    exportShow("Cancel gevraagd… (wacht even)", 100);
  });
}

        
        // ---------- live WAV recorder (records exactly what you hear) ----------
        let liveRec = null;

        function flattenFloat32(chunks){
          let total = 0;
          for(const c of chunks) total += c.length;
          const out = new Float32Array(total);
          let o = 0;
          for(const c of chunks){ out.set(c, o); o += c.length; }
          return out;
        }

        function encodeWavFromPCM(left, right, sampleRate){
          const numChannels = 2;
          const length = Math.min(left.length, right.length);
          const bytesPerSample = 2;
          const blockAlign = numChannels * bytesPerSample;
          const byteRate = sampleRate * blockAlign;
          const dataSize = length * blockAlign;

          const buffer = new ArrayBuffer(44 + dataSize);
          const view = new DataView(buffer);

          function writeStr(off, s){
            for(let i=0;i<s.length;i++) view.setUint8(off+i, s.charCodeAt(i));
          }

          writeStr(0, "RIFF");
          view.setUint32(4, 36 + dataSize, true);
          writeStr(8, "WAVE");
          writeStr(12, "fmt ");
          view.setUint32(16, 16, true);
          view.setUint16(20, 1, true); // PCM
          view.setUint16(22, numChannels, true);
          view.setUint32(24, sampleRate, true);
          view.setUint32(28, byteRate, true);
          view.setUint16(32, blockAlign, true);
          view.setUint16(34, 16, true);
          writeStr(36, "data");
          view.setUint32(40, dataSize, true);

          let off = 44;
          for(let i=0;i<length;i++){
            const l = Math.max(-1, Math.min(1, left[i]));
            const r = Math.max(-1, Math.min(1, right[i]));
            view.setInt16(off, (l < 0 ? l * 0x8000 : l * 0x7FFF) | 0, true); off += 2;
            view.setInt16(off, (r < 0 ? r * 0x8000 : r * 0x7FFF) | 0, true); off += 2;
          }
          return new Blob([buffer], { type: "audio/wav" });
        }

        

// ---------- LIVE VIDEO EXPORT (frequency -> black/white + audio) ----------
const recordLiveVideoBtn = document.getElementById("recordLiveVideo");

// Ensure canvas exists (some webviews may drop it or not parse it as expected)
let freqCanvas = document.getElementById("freqCanvas");
if(!freqCanvas){
  freqCanvas = document.createElement("canvas");
  freqCanvas.id = "freqCanvas";
  freqCanvas.width = 960;
  freqCanvas.height = 540;
  freqCanvas.style.display = "none";
  document.body.appendChild(freqCanvas);
}
const freqCtx = freqCanvas.getContext("2d");

let freqAnalyser = null;
let freqBins = null;

function ensureFreqAnalyser(){
  if(freqAnalyser) return;
  if(!audioCtx) throw new Error("audioCtx not ready");
  freqAnalyser = audioCtx.createAnalyser();
  freqAnalyser.fftSize = 2048;
  freqAnalyser.smoothingTimeConstant = 0.7;
  try{ masterGain.connect(freqAnalyser); }catch{}
  freqBins = new Uint8Array(freqAnalyser.frequencyBinCount);
}

function setupFreqCanvas(){
  // Prepare analyser + canvas for LIVE VIDEO recording visual
  try{ ensureFreqAnalyser(); }catch(e){ /* ok */ }

  if(!freqCanvas) throw new Error("freqCanvas missing");
  // Keep a stable resolution (good for phones); you can tweak later if you want
  freqCanvas.width = 960;
  freqCanvas.height = 540;

  // reset timing + clear
  try{ lastFrameT = 0; }catch{}
  try{
    if(freqCtx){
      freqCtx.setTransform(1,0,0,1,0,0);
      freqCtx.clearRect(0,0,freqCanvas.width,freqCanvas.height);
      freqCtx.fillStyle = "#000";
      freqCtx.fillRect(0,0,freqCanvas.width,freqCanvas.height);
    }
  }catch{}

  // start draw loop
  try{ startFreqDrawLoop(); }catch{}
}

let videoRec = null;
let liveVideoRecording = false;
let videoChunks = [];
let videoAnim = 0;
let audioDest = null;
let canvasStream = null;

function chooseBestVideoMime(){
  // Force MP4 when supported (Android / Chrome / WebView)
  const mp4 = "video/mp4;codecs=avc1.42E01E,mp4a.40.2";
  try{
    if(window.MediaRecorder && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(mp4)){
      return mp4;
    }
  }catch(e){}

  // Fallbacks (only if MP4 truly not supported)
  const fb = ["video/mp4","video/webm;codecs=vp8,opus","video/webm"];
  for(const c of fb){
    try{ if(MediaRecorder.isTypeSupported(c)) return c; }catch(e){}
  }
  return "";
}

let blinkPhase = 0;
let blinkHz = 2;          // current blink frequency
let targetBlinkHz = 2;    // from audio
let lastFrameT = 0;

function hzFromSpectrum(){
  if(!freqAnalyser || !freqBins) return 2;

  freqAnalyser.getByteFrequencyData(freqBins);

  // Find peak bin (simple + robust)
  let maxV = -1, maxI = 0;
  for(let i=0;i<freqBins.length;i++){
    const v = freqBins[i];
    if(v > maxV){ maxV = v; maxI = i; }
  }

  // Convert bin -> Hz
  const nyquist = audioCtx.sampleRate / 2;
  const freq = (maxI / freqBins.length) * nyquist;

  // Map audible Hz to visible blink Hz (log scale)
  const f = Math.max(20, Math.min(8000, freq));
  const mapped = 0.5 + (Math.log(f/20) / Math.log(8000/20)) * (15 - 0.5); // 0.5..15 Hz
  return mapped;
}

function drawFreqFrame(t){
  if(!freqCanvas || !freqCtx) return;
  if(!freqAnalyser) return;

  // time step
  if(!lastFrameT) lastFrameT = t || performance.now();
  const nowT = t || performance.now();
  const dt = Math.min(0.05, Math.max(0, (nowT - lastFrameT) / 1000));
  lastFrameT = nowT;

  // update spectrum (FFT)
// (we read bins here so the visual has a direct relationship with the FFT)
freqAnalyser.getByteFrequencyData(freqBins);

// Find peak bin (for blinkHz mapping / timing feel)
let maxV = -1, maxI = 0;
for(let i=0;i<freqBins.length;i++){
  const v = freqBins[i];
  if(v > maxV){ maxV = v; maxI = i; }
}

// Convert peak bin -> Hz
const nyquist = audioCtx.sampleRate / 2;
const peakHz = (maxI / freqBins.length) * nyquist;

// Map audible Hz to a motion rate (log scale)
const f = Math.max(20, Math.min(8000, peakHz));
targetBlinkHz = 0.5 + (Math.log(f/20) / Math.log(8000/20)) * (15 - 0.5); // 0.5..15 Hz

// smooth rate to avoid jitter
blinkHz += (targetBlinkHz - blinkHz) * Math.min(1, dt * 8);

// advance phase (used for subtle drift)
blinkPhase += (2 * Math.PI * blinkHz) * dt;

// --- Visual: INTENSE full-screen FFT-driven pixel storm ---
const W = freqCanvas.width|0;
const H = freqCanvas.height|0;

// Fast fade to keep motion energetic
freqCtx.fillStyle = "rgba(0,0,0,0.28)";
freqCtx.fillRect(0, 0, W, H);

// Global energy (sum of FFT)
let sum = 0;
for(let i=0;i<freqBins.length;i++) sum += freqBins[i];
const energy = Math.min(1, sum / (freqBins.length * 180));

// Massive pixel count based on energy
const baseCount = 3000;
const extra = Math.floor(energy * 9000);
const N = baseCount + extra;

for(let k=0; k<N; k++){
  // pick random bin, weighted by amplitude
  const bi = (Math.random() * freqBins.length) | 0;
  const amp = freqBins[bi];
  if(Math.random() * 255 > amp) continue;

  // FULL SCREEN randomness
  const x = (Math.random() * W) | 0;
  const y = (Math.random() * H) | 0;

  // color linked to frequency + time
  const hue = liveVideoRecording ? (Math.random()*360) : (((bi / freqBins.length) * 360 + blinkPhase * 120) % 360);

  // size + alpha linked to amplitude
  const sz = 1 + ((amp / 255) * 5) | 0;
  const alpha = 0.25 + (amp / 255) * 0.75;

  freqCtx.fillStyle = `hsla(${hue.toFixed(1)}, 100%, 55%, ${alpha.toFixed(3)})`;
  freqCtx.fillRect(x, y, sz, sz);
}}

function startFreqDrawLoop(){
  if(videoAnim) return;
  const loop = (t)=>{
    drawFreqFrame(t);
    videoAnim = requestAnimationFrame(loop);
  };
  videoAnim = requestAnimationFrame(loop);
}

function stopFreqDrawLoop(){
  if(!videoAnim) return;
  cancelAnimationFrame(videoAnim);
  videoAnim = 0;
}

async function startLiveVideoRecord(){
  
  liveVideoRecording = true;
if(videoRec) return;
  if(!window.MediaRecorder) throw new Error("MediaRecorder not supported");
  if(audioCtx.state==="suspended") await audioCtx.resume();

  // --- Canvas (video) stream ---
  setupFreqCanvas();
  freqCanvas.style.display = "block";
  const canvasStream = freqCanvas.captureStream(60);

  

  // preview routing flag (used in onstop cleanup)
  let previewActive = false;
// --- Audio tap for video recording (records EXACTLY what you hear incl. Master FX) ---
  // We tap from the FINAL output node (the global softClip in the main audio chain).
  // This ensures the recorded audio matches playback (all FX + limiter).
  const audioDest = audioCtx.createMediaStreamDestination();
  const _vidTap = audioCtx.createGain();
  _vidTap.gain.value = 1.0;

  // Try global softClip -> tap -> audioDest. Fallbacks are comp or masterGain.
  try{
    if(typeof softClip === "undefined" || !softClip) throw new Error("global softClip missing");
    softClip.connect(_vidTap);
    _vidTap.connect(audioDest);
  }catch(e){
    try{
      if(typeof comp !== "undefined" && comp){ comp.connect(_vidTap); _vidTap.connect(audioDest); }
      else throw new Error("global comp missing");
    }catch(e2){
      try{ masterGain.connect(audioDest); }catch{}
    }
  }

  // --- Mix canvas video + audio into one stream for MediaRecorder ---

  const mixed = new MediaStream();
  canvasStream.getVideoTracks().forEach(t=> mixed.addTrack(t));
  audioDest.stream.getAudioTracks().forEach(t=> mixed.addTrack(t));

  const mime = chooseBestVideoMime();
  videoChunks = [];

  videoRec = new MediaRecorder(mixed, mime ? { mimeType: mime, audioBitsPerSecond: 192000, videoBitsPerSecond: 4000000 } : { audioBitsPerSecond: 192000, videoBitsPerSecond: 4000000 });
  videoRec.ondataavailable = (e)=>{ if(e.data && e.data.size) videoChunks.push(e.data); };

  videoRec.onstop = ()=>{
    
    liveVideoRecording = false;
try{
      stopFreqDrawLoop();

      // Cleanup recording tap (DO NOT break the main audio graph)
      try{ if(typeof _vidTap !== "undefined" && _vidTap) _vidTap.disconnect(); }catch{}
      try{ if(typeof softClip !== "undefined" && softClip && typeof _vidTap !== "undefined" && _vidTap) softClip.disconnect(_vidTap); }catch{}

      // Rebuild master routing just in case anything got disconnected
      try{ if(typeof rebuildMasterFx === "function") rebuildMasterFx(); }catch{}

      // Restore preview routing if needed
      // (preview disabled in this build)

      try{ canvasStream.getTracks().forEach(t=>t.stop()); }catch{}
      try{ audioDest.stream.getTracks().forEach(t=>t.stop()); }catch{}
      try{ freqCanvas.style.display = "none"; }catch{}

      const usedMime = (videoRec && videoRec.mimeType) ? videoRec.mimeType : (mime || 'video/webm');
      const blob = new Blob(videoChunks, { type: usedMime });
      const url = URL.createObjectURL(blob);

      const ext = "mp4";
      const base = (getLoadedMidiBaseName() || sanitizeFileName(fileNameEl.value));
      const a = document.createElement("a");
      a.href = url;
      a.download = `${base}.${ext}`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(()=> URL.revokeObjectURL(url), 30_000);

      setStatus(`video exported (${ext})`);
    }catch(e){
      showError(e);
    } finally {
      try{ if(_vidKeepAlive){ clearInterval(_vidKeepAlive); _vidKeepAlive = 0; } }catch{}
      videoRec = null;
      videoChunks = [];
      if(recordLiveVideoBtn) recordLiveVideoBtn.textContent = "Export LIVE VIDEO";
    }
  };

  // Keep AudioContext alive on some Android webviews (prevents mid-record silence)
  let _vidKeepAlive = setInterval(()=>{ try{ audioCtx.resume(); }catch{} }, 1000);

  videoRec.start(250); // chunk every 250ms
  if(recordLiveVideoBtn) recordLiveVideoBtn.textContent = "Stop VIDEO";
  setStatus("recording video…");
}

function stopLiveVideoRecord(){
  try{
    if(videoRec && videoRec.state !== "inactive"){
      videoRec.stop();
    }
  }catch(e){ showError(e); }
}

if(recordLiveVideoBtn){
  recordLiveVideoBtn.addEventListener("click", ()=>{
    // Toggle
    if(videoRec) stopLiveVideoRecord();
    else startLiveVideoRecord().catch(showError);
  });
}

async function recordLiveWav(){
          if(liveRec) return;
          if(audioCtx.state === "suspended") await audioCtx.resume();

          // Ensure we record exactly one full sequence at current BPM
          const bpmSnap = Number(bpm) || 120;
          let stepDur = intervalMs(bpmSnap) / 1000;
          if(!Number.isFinite(stepDur) || stepDur <= 0) stepDur = 0.25;
          stepDur = Math.max(0.01, stepDur);
          const rows = (Number.isFinite(ROWS) && ROWS > 0) ? ROWS : 1;
          const durationSec = rows * stepDur;

          exportCancelRequested = false;
          exportShow(`LIVE record… 00:00 / ${String(Math.floor(durationSec/60)).padStart(2,"0")}:${String(Math.floor(durationSec%60)).padStart(2,"0")}  @ ${fmt2(bpmSnap)} BPM`, 0);

          // Tap the final chain (comp -> destination). We also connect comp -> processor.
          if(typeof comp === "undefined"){
            throw new Error("Live recorder: compressor node (comp) not found");
          }

          const bufferSize = 4096;
          const proc = audioCtx.createScriptProcessor(bufferSize, 2, 2);
          const zero = audioCtx.createGain();
          zero.gain.value = 0;

          const L = [];
          const R = [];
          proc.onaudioprocess = (e)=>{
            const in0 = e.inputBuffer.getChannelData(0);
            const in1 = e.inputBuffer.numberOfChannels > 1 ? e.inputBuffer.getChannelData(1) : in0;
            L.push(new Float32Array(in0));
            R.push(new Float32Array(in1));
          };

          // Feed processor from comp, but keep processor output silent
          softClip.connect(proc);
          proc.connect(zero);
          zero.connect(audioCtx.destination);

          liveRec = { proc, zero, startTime: performance.now(), durationSec };

          // Start playback from beginning (so export matches what you hear)
          try{ document.getElementById("stop").click(); }catch{}
          index = 0;
          try{ document.getElementById("play").click(); }catch{}

          // Progress timer
          const progT = setInterval(()=>{
            if(!liveRec) { clearInterval(progT); return; }
            const t = (performance.now() - liveRec.startTime) / 1000;
            const pct = Math.max(0, Math.min(100, (t / liveRec.durationSec) * 100));
            const mm = String(Math.floor(t/60)).padStart(2,"0");
            const ss = String(Math.floor(t%60)).padStart(2,"0");
            const tt = liveRec.durationSec;
            const mmT = String(Math.floor(tt/60)).padStart(2,"0");
            const ssT = String(Math.floor(tt%60)).padStart(2,"0");
            exportShow(`LIVE record… ${mm}:${ss} / ${mmT}:${ssT}  @ ${fmt2(bpmSnap)} BPM`, pct);
          }, 120);

          // Stop after duration
          setTimeout(()=>{
            try{ clearInterval(progT); }catch{}
            stopLiveWav(L, R, bpmSnap);
          }, Math.max(50, durationSec * 1000));
        }

        function stopLiveWav(Lchunks, Rchunks, bpmSnap){
          const rec = liveRec;
          if(!rec) return;
          liveRec = null;

          try{ document.getElementById("stop").click(); }catch{}

          try{ rec.proc.disconnect(); }catch{}
          try{ rec.zero.disconnect(); }catch{}
          try{ softClip.disconnect(rec.proc); }catch{}

          const left = flattenFloat32(Lchunks);
          const right = flattenFloat32(Rchunks);
          const wavBlob = encodeWavFromPCM(left, right, audioCtx.sampleRate || 44100);

          const base = sanitizeFileName((fileNameEl && fileNameEl.value) ? fileNameEl.value : "sequencer-live");
          const filename = base + `_LIVE_${fmt2(bpmSnap)}bpm.wav`;

          const url = URL.createObjectURL(wavBlob);
          const a = document.createElement("a");
          a.href = url;
          a.download = filename;
          document.body.appendChild(a);
          a.click();
          a.remove();
          URL.revokeObjectURL(url);

          exportShow("LIVE WAV klaar!", 100);
          setTimeout(()=>exportHide(), 700);
          setStatus("live wav downloaded");
        }


        // ---------- constants ----------
        const STORAGE_KEY = "sequencer_state_fx15_sampler_midi_resize_v1";
        const STORAGE_KEY_FILENAME = STORAGE_KEY + "_filename";


        // ---------- autosave (extra safety) ----------
        // The app already autosaves on edits; this adds:
        // - periodic forced save
        // - forced save when tab/app is backgrounded/closed
        const AUTOSAVE_EVERY_MS = 30 * 1000; // 30s

        // Default grid size (will be resized by MIDI import if needed)
        let ROWS = 128;
        let COLS = 10;

        const EPS = 0.00001;
        const CLICK_FADE = 0.012; // seconds: anti-click fade (increased to reduce clicks)
        const STEP_FADE = 0.04; // seconds: stronger fade-in/out per step (more anti-click) // seconds: fade-in/out per step (extra anti-click) // seconds: fade-in/out per step (extra anti-click)


        // ---------- ADSR master toggle ----------
        // Default OFF (sequencer plays without ADSR unless enabled)
        let ADSR_ENABLED = false;
        let ADSR_SCALE = 1.0; // global multiplier for ADSR (times + sustain)

        function getEffectiveADSR(cell){
          if(ADSR_ENABLED) return { a: 1*ADSR_SCALE, d: 1*ADSR_SCALE, s: Math.min(10, 1*ADSR_SCALE), r: 1*ADSR_SCALE };
          // ADSR OFF: immediate, full level, small release to avoid clicks
          return { a: STEP_FADE, d: 0, s: 1.0, r: STEP_FADE };
        }

        // 15 FX types
        const FX_TYPES = [
          "none",
          "delay",
          "reverb",
          "chorus",
          "flanger",
          "phaser",
          "tremolo",
          "vibrato",
          "distortion",
          "bitcrush",
          "compressor",
          "limiter",
          "pan",
          "ringmod",
          "wah", "vibpanreverb"
        ];
        // ---------- Master FX UI ----------
        // Global settings object lives on window to avoid TDZ / init order issues
        const masterFxSettings = window.__masterFxSettings || (window.__masterFxSettings = {
          chainLen: 4,
          chain: [
            { type:"none", p1:0.25, p2:0.25 },
            { type:"none", p1:0.25, p2:0.25 },
            { type:"none", p1:0.25, p2:0.25 },
            { type:"none", p1:0.25, p2:0.25 },
          ]
        });

        const masterFXTypeEls = [
          document.getElementById("masterFXType1"),
          document.getElementById("masterFXType2"),
          document.getElementById("masterFXType3"),
          document.getElementById("masterFXType4"),
        ];
        const masterFX1Els = [
          document.getElementById("masterFX1_1"),
          document.getElementById("masterFX1_2"),
          document.getElementById("masterFX1_3"),
          document.getElementById("masterFX1_4"),
        ];
        const masterFX2Els = [
          document.getElementById("masterFX2_1"),
          document.getElementById("masterFX2_2"),
          document.getElementById("masterFX2_3"),
          document.getElementById("masterFX2_4"),
        ];
        const masterFX1ValEls = [
          document.getElementById("masterFX1Val_1"),
          document.getElementById("masterFX1Val_2"),
          document.getElementById("masterFX1Val_3"),
          document.getElementById("masterFX1Val_4"),
        ];
        const masterFX2ValEls = [
          document.getElementById("masterFX2Val_1"),
          document.getElementById("masterFX2Val_2"),
          document.getElementById("masterFX2Val_3"),
          document.getElementById("masterFX2Val_4"),
        ];

        function masterFxUpdateLabels(){
          for(let i=0;i<4;i++){
            const slot = masterFxSettings.chain[i];
            if(masterFX1ValEls[i]) masterFX1ValEls[i].textContent = (Number(slot.p1)||0).toFixed(2);
            if(masterFX2ValEls[i]) masterFX2ValEls[i].textContent = (Number(slot.p2)||0).toFixed(2);
          }
        }

        const fxOptionsHTML = FX_TYPES.map(t=>`<option value="${t}">${t}</option>`).join("");
        for(let i=0;i<4;i++){
          const slot = masterFxSettings.chain[i];
          const sel = masterFXTypeEls[i];
          if(sel){
            sel.innerHTML = fxOptionsHTML;
            sel.value = slot.type || "none";
            sel.addEventListener("change", ()=>{
              slot.type = sel.value;
              if(typeof rebuildMasterFx === "function") rebuildMasterFx();
              try{ scheduleSave(); }catch{}
            });
          }
          const r1 = masterFX1Els[i];
          if(r1){
            r1.value = String(slot.p1 ?? 0.25);
            r1.addEventListener("input", ()=>{
              slot.p1 = Number(r1.value)||0;
              masterFxUpdateLabels();
              if(typeof rebuildMasterFx === "function") rebuildMasterFx();
            });
            r1.addEventListener("change", ()=>{ try{ scheduleSave(); }catch{} });
          }
          const r2 = masterFX2Els[i];
          if(r2){
            r2.value = String(slot.p2 ?? 0.25);
            r2.addEventListener("input", ()=>{
              slot.p2 = Number(r2.value)||0;
              masterFxUpdateLabels();
              if(typeof rebuildMasterFx === "function") rebuildMasterFx();
            });
            r2.addEventListener("change", ()=>{ try{ scheduleSave(); }catch{} });
          }
        }
        masterFxUpdateLabels();


        // ---------- helpers ----------
        function clamp(n,min,max){ return Math.min(max, Math.max(min, n)); }
        function clampInt(n,min,max){
          n = Number(n);
          if(!Number.isFinite(n)) n = min;
          return Math.min(max, Math.max(min, Math.round(n)));
        }
        function fmt2(n){ return Number(n).toFixed(2); }

        function intervalMs(bpm){ return 60000 / bpm / 2; } // 1/8
        function midiNoteToHz(note){ return 440 * Math.pow(2, (note - 69)/12); }

        function sanitizeFileName(name){
          const cleaned = String(name || "")
            .trim()
            .replace(/[\\/:*?"<>|]+/g, "-")
            .replace(/\s+/g, "-")
            .replace(/-+/g, "-");
          return cleaned.length ? cleaned : "sequencer-state";
        }

        // ---------- filename autosave + GK default ----------
        const fileNameEl = document.getElementById("fileName");

        function pad2(n){ return String(n).padStart(2,"0"); }
        function pad3(n){ return String(n).padStart(3,"0"); }
        function todayYMD(){
          const d = new Date();
          return `${d.getFullYear()}${pad2(d.getMonth()+1)}${pad2(d.getDate())}`;
        }
        function gkCounterKey(ymd){ return `GK_COUNTER_${ymd}`; }

        function getCurrentGKName(){
          const ymd = todayYMD();
          let n = 0;
          try{
            const raw = localStorage.getItem(gkCounterKey(ymd));
            if(raw != null) n = clampInt(raw, 0, 999);
          }catch{}
          return `GK${ymd}${pad3(n)}`;
        }
        function bumpGKCounter(){
          const ymd = todayYMD();
          try{
            const key = gkCounterKey(ymd);
            const raw = localStorage.getItem(key);
            const n = (raw == null) ? 0 : clampInt(raw, 0, 999);
            const next = (n >= 999) ? 0 : (n + 1);
            localStorage.setItem(key, String(next));
          }catch{}
        }

        // Load saved filename, otherwise use GKYYYYMMDD### (per day counter)
        try{
          const savedName = localStorage.getItem(STORAGE_KEY_FILENAME);
          if(savedName && String(savedName).trim()){
            fileNameEl.value = savedName;
          } else {
            fileNameEl.value = getCurrentGKName();
            localStorage.setItem(STORAGE_KEY_FILENAME, fileNameEl.value);
          }
        }catch{
          // no localStorage: still set a sane name
          fileNameEl.value = getCurrentGKName();
        }

        fileNameEl.addEventListener("input", ()=>{
          try{ localStorage.setItem(STORAGE_KEY_FILENAME, fileNameEl.value || ""); }catch{}
        });

        // ---------- BPM UI ----------
        const bpmSlider = document.getElementById("bpmSlider");
        const bpmInput = document.getElementById("bpmInput");

        // ---------- Smooth / Glide (global) ----------
        let glideEnabled = false;
        let glideTimeSec = 0.18;   // seconds
        let overlapRatio = 0.35;   // extra fraction of step for release/overlap

        const glideToggleEl = document.getElementById("glideToggle");
        const glideTimeEl   = document.getElementById("glideTime");
        const glideTimeValEl= document.getElementById("glideTimeVal");
        const overlapEl     = document.getElementById("overlapRatio");
        const overlapValEl  = document.getElementById("overlapRatioVal");

        function syncGlideUI(){
          try{
            glideEnabled = !!glideToggleEl.checked;
            glideTimeSec = Math.max(0, Number(glideTimeEl.value)||0);
            overlapRatio = Math.max(0, Number(overlapEl.value)||0);
            if(glideTimeValEl) glideTimeValEl.textContent = glideTimeSec.toFixed(2)+"s";
            if(overlapValEl) overlapValEl.textContent = overlapRatio.toFixed(2);
          }catch{}
        }
        if(glideToggleEl) glideToggleEl.addEventListener("change", syncGlideUI);
        if(glideTimeEl)   glideTimeEl.addEventListener("input", syncGlideUI);
        if(overlapEl)     overlapEl.addEventListener("input", syncGlideUI);
        syncGlideUI();
        let bpm = 120.0;

        function setBpm(v){
          v = Number(v);
          if(!Number.isFinite(v) || v <= 0) return;
          v = Math.min(240, Math.max(1, v));
          bpm = v;
          bpmSlider.value = String(bpm);
          bpmInput.value = fmt2(bpm);
          if(playing) restartTimer();
          scheduleSave();
        }
        bpmSlider.value = String(bpm);
        bpmInput.value = fmt2(bpm);
        bpmSlider.addEventListener("input", ()=> setBpm(bpmSlider.value));
        bpmInput.addEventListener("change", ()=> setBpm(bpmInput.value));
        bpmInput.addEventListener("keydown", (e)=>{
          if(e.key === "Enter"){ e.preventDefault(); setBpm(bpmInput.value); bpmInput.blur(); }
        });


        // ---------- ADSR toggle UI ----------
        const adsrToggleEl = document.getElementById("adsrToggle");
        if(adsrToggleEl){
          adsrToggleEl.checked = false; // default OFF
          ADSR_ENABLED = false;

          adsrToggleEl.addEventListener("change", ()=>{
            ADSR_ENABLED = !!adsrToggleEl.checked;
            try{ scheduleSave(); }catch{}
            setStatus(ADSR_ENABLED ? "ADSR on" : "ADSR off");
          });
        }



const adsrScaleEl = document.getElementById("adsrScale");
const adsrScaleValEl = document.getElementById("adsrScaleVal");
function setAdsrScaleUI(v){
  const vv = Math.max(0.1, Math.min(4, Number(v) || 1));
  ADSR_SCALE = vv;
  if(adsrScaleEl) adsrScaleEl.value = String(vv);
  if(adsrScaleValEl) adsrScaleValEl.textContent = vv.toFixed(1);
}

function getLoadedMidiBaseName(){
  try{
    const n = (window._lastLoadedMidiFileName || "").trim();
    if(!n) return "";
    return sanitizeFileName(n.replace(/\.(mid|midi)$/i,""));
  }catch(e){
    return "";
  }
}

if(adsrScaleEl){
  setAdsrScaleUI(1.0);
  adsrScaleEl.addEventListener("input", ()=>{
    setAdsrScaleUI(adsrScaleEl.value);
  });
  adsrScaleEl.addEventListener("change", ()=>{
    try{ scheduleSave(); }catch{}
  });
}

        // ---------- Audio (live) ----------
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const masterGain = audioCtx.createGain();
        // Lower master to reduce clipping (sustain can be 0..10)
        masterGain.gain.value = 0.12;

        // Gentle limiter chain to prevent crackle/clipping:
        // masterGain -> compressor -> softClip -> destination
        const comp = audioCtx.createDynamicsCompressor();
        comp.threshold.value = -24;
        comp.knee.value = 24;
        comp.ratio.value = 12;
        comp.attack.value = 0.002;
        comp.release.value = 0.22;

        const softClip = audioCtx.createWaveShaper();
        // Soft clip curve
        const n = 2048;
        const curve = new Float32Array(n);
        for (let i = 0; i < n; i++) {
          const x = (i * 2) / (n - 1) - 1;
          // tanh-style soft clip
          curve[i] = Math.tanh(3.2 * x);
        }
        softClip.curve = curve;
        softClip.oversample = "4x";

        // Master FX settings are stored on window.__masterFxSettings (configured via the 4-slot UI)
        let _masterFxCleanup = ()=>{};

        function rebuildMasterFx(){
          // Use global chain settings (4 slots). Each slot uses createFXChain(...) as a single-effect builder.
          const masterFxSettings = window.__masterFxSettings || (window.__masterFxSettings = {
            chainLen: 4,
            chain: [
              { type:"none", p1:0.25, p2:0.25 },
              { type:"none", p1:0.25, p2:0.25 },
              { type:"none", p1:0.25, p2:0.25 },
              { type:"none", p1:0.25, p2:0.25 },
            ]
          });

          try{ masterGain.disconnect(); }catch{}
          try{ _masterFxCleanup(); }catch{}
          _masterFxCleanup = ()=>{};

          let cur = masterGain;
          const cleanups = [];

          try{
            const chainLen = 4; // always 4 slots as requested
            for(let i=0;i<chainLen;i++){
              const slot = masterFxSettings.chain[i] || {type:"none",p1:0,p2:0};
              const built = createFXChain(audioCtx, slot, cur);
              if(built && built.cleanup) cleanups.push(built.cleanup);
              cur = (built && built.out) ? built.out : cur;
            }
          }catch(e){
            // If any FX build fails, fall back to dry
            cur = masterGain;
          }

          _masterFxCleanup = ()=>{ for(const c of cleanups){ try{ c(); }catch{} } };

          try{
            cur.connect(comp);
          }catch(e){
            try{ masterGain.connect(comp); }catch{}
          }
        }

        comp.connect(softClip);
        softClip.connect(audioCtx.destination);
        if(typeof rebuildMasterFx === 'function') rebuildMasterFx();
// Sample cache (by objectURL)
        const sampleCache = new Map(); // url -> AudioBuffer

        async function decodeSampleWithContext(ctx, arrayBuffer){
          return await new Promise((resolve, reject)=>{
            try{
              ctx.decodeAudioData(arrayBuffer.slice(0), resolve, reject);
            }catch(e){ reject(e); }
          });
        }

        async function loadSampleToCache(url, file){
          const buf = await file.arrayBuffer();
          const ab = await decodeSampleWithContext(audioCtx, buf);
          sampleCache.set(url, ab);
          return ab;
        }

        async function getSampleBufferForCell(ctx, cell){
          if(!cell.sample || !cell.sample.url) return null;
          const url = cell.sample.url;
          // OfflineAudioContext can't decode from AudioBuffer directly, but can reuse AudioBuffer from live ctx
          // In practice AudioBuffer is compatible across contexts in browsers.
          return sampleCache.get(url) || null;
        }

        // ---------- state arrays ----------
        let gridOn = [];
        let gridData = [];
        function makeDefaultCell(){
          return {
            hold: false,
            freq: 440.0,
            wave: "sine",
            source: "osc", // "osc" or "sample"
            sample: { url:"", name:"", startPct:0.00, lengthPct:100.00 },
            adsr: { a:0.01, d:0.15, s:0.6, r:0.2 },
            fx: { type:"none", p1:0.5, p2:0.5 },
            midi: { enable:false, ch:1, cmd:"note", note:60, vel:100, ccN:1, ccV:0, program:0, pitchbend:0 }
          };
        }

        function initGrid(rows, cols){
          ROWS = rows;
          COLS = 10; // fixed 10 columns
          cols = COLS;
          gridOn = Array.from({length: ROWS}, ()=> Array.from({length: COLS}, ()=> false));
          gridData = Array.from({length: ROWS}, ()=> Array.from({length: COLS}, ()=> makeDefaultCell()));
        }

        initGrid(ROWS, COLS);

        // ---------- notes per line (fixed) ----------
        const notesPerLineEl = document.getElementById("notesPerLine");
        if (notesPerLineEl){
          notesPerLineEl.value = "10";
          notesPerLineEl.disabled = true;
        }
        // Grid is always 10 columns wide (128x10 default; rows may grow when importing MIDI).


        
        // ---------- Shuffle (1 note per step, 20..100 Hz) ----------
        document.getElementById("shuffle").addEventListener("click", ()=>{
          for(let r=0;r<ROWS;r++){            let cPick = Math.floor(Math.random() * COLS);
            // Prefer an empty cell so this shuffle is additive
            for(let t=0;t<16;t++){
              if(!gridOn[r][cPick]) break;
              cPick = Math.floor(Math.random() * COLS);
            }
            gridOn[r][cPick] = true;

            const cell = gridData[r][cPick];
            cell.freq = Number((20 + Math.random() * 80).toFixed(2)); // 20..100
            cell.source = cell.source || "osc"; // keep sampler if already set, but ensure audible
          }
          closeDropdown();
          buildGrid();

          scheduleSave(true);
          setStatus("shuffled");
        });


        document.getElementById("shuffleHiVibPanRev").addEventListener("click", ()=>{
          for(let r=0;r<ROWS;r++){            // pick one column
            let cPick = Math.floor(Math.random() * COLS);
            // Prefer an empty cell so this shuffle is additive
            for(let t=0;t<16;t++){
              if(!gridOn[r][cPick]) break;
              cPick = Math.floor(Math.random() * COLS);
            }
            gridOn[r][cPick] = true;

            const cell = gridData[r][cPick];

            // High freqs 1000..20000 Hz
            cell.freq = Number((1000 + Math.random() * 19000).toFixed(2));

            // Max-ish vibrato + random pan + reverb
            cell.fx.type = "vibpanreverb";
            cell.fx.p1 = 1.0; // vibrato depth/rate max
            cell.fx.p2 = 1.0; // reverb amount max
            cell.fx.pan = Number((Math.random()*2 - 1).toFixed(3));

            // keep source as oscillator
            cell.source = "osc";
            cell.wave = "sine";
          }
          closeDropdown();
          buildGrid();
          scheduleSave(true);
          setStatus("hi vib+pan+reverb shuffled");
        });


        
// ---- Shuffle Sample slices across 10% of steps (multi files / directory) ----
const shuffleSampleBtn = document.getElementById("shuffleSample10");
const shuffleSampleFile = document.getElementById("shuffleSampleFile");

async function decodeAudioFileToBuffer(file){
  const arr = await file.arrayBuffer();
  if(audioCtx.state === "suspended") await audioCtx.resume();
  // decode via live AudioContext (reused buffers for playback)
  return await audioCtx.decodeAudioData(arr.slice(0));
}

function shuffledArray(n){
  const a = Array.from({length:n}, (_,i)=>i);
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    const t=a[i]; a[i]=a[j]; a[j]=t;
  }
  return a;
}

function pickUniqueSeconds(count, maxSecInt){
  const pool = Array.from({length:maxSecInt+1}, (_,i)=>i);
  // If pool is smaller than count, allow repeats.
  if(pool.length >= count){
    for(let i=pool.length-1;i>0;i--){
      const j=Math.floor(Math.random()*(i+1));
      const t=pool[i]; pool[i]=pool[j]; pool[j]=t;
    }
    return pool.slice(0, count);
  }
  const out=[];
  for(let i=0;i<count;i++){
    out.push(maxSecInt>0 ? Math.floor(Math.random()*(maxSecInt+1)) : 0);
  }
  return out;
}

function applySampleShuffleMulti(buffer, name, placements=10){
  // For EACH sample:
  // - choose a random pool of rows = 10% of sequence (at least 'placements')
  // - place 'placements' slices (1.00s, random integer seconds) inside that pool
  const rowsN = (Number.isFinite(ROWS) && ROWS>0) ? ROWS : 1;
  const colsN = (Number.isFinite(COLS) && COLS>0) ? COLS : 10;

  const poolSize = Math.max(placements, Math.round(rowsN * 0.10));
  const pool = shuffledArray(rowsN).slice(0, Math.min(rowsN, poolSize));
  const pickedRows = pool.slice(0, Math.min(placements, pool.length));

  const sampleDur = (buffer && Number.isFinite(buffer.duration)) ? buffer.duration : 0;
  const sliceLenSec = 1.0;
  const safeSliceLen = (sampleDur > 0) ? Math.min(sliceLenSec, sampleDur) : sliceLenSec;
  const maxStartSec = (sampleDur > 0) ? Math.max(0, sampleDur - safeSliceLen) : 0;
  const maxSecInt = (sampleDur > 0) ? Math.floor(maxStartSec) : 0;

  // Cache buffer under a synthetic key so playback uses it
  const sampleKey = "__shufflesample__" + Date.now() + "__" + Math.floor(Math.random()*1e9);
  try { sampleCache.set(sampleKey, buffer); } catch(e) {}

  // Pick 'placements' random integer seconds (unique if possible)
  const seconds = pickUniqueSeconds(pickedRows.length, maxSecInt);

  for(let i=0;i<pickedRows.length;i++){
    const r = pickedRows[i];

    // choose a column (prefer empty but keep additive)
    let cPick = Math.floor(Math.random() * colsN);
    for(let t=0;t<24;t++){
      if(!gridOn[r][cPick]) break;
      cPick = Math.floor(Math.random() * colsN);
    }

    gridOn[r][cPick] = true;

    const cell = gridData[r][cPick];
    cell.source = "sample";
    cell.sample.enabled = true;
    cell.sample.url = sampleKey;
    cell.sample.name = name || "sample";

    const startSec = (sampleDur > 0) ? Math.min(maxStartSec, seconds[i] || 0) : 0;

    if(sampleDur > 0){
      const startPct = (startSec / sampleDur) * 100;
      const lenPct = (safeSliceLen / sampleDur) * 100;
      cell.sample.startPct = Number(startPct.toFixed(2));
      cell.sample.lengthPct = Number(lenPct.toFixed(2));
    } else {
      cell.sample.startPct = 0.00;
      cell.sample.lengthPct = 100.00;
    }

    // per-step slice (no hold)
    cell.hold = false;
  }
}

async function applyDirectoryOrMultiShuffle(files){
  // Process files sequentially (mobile-safe)
  const list = Array.from(files || []).filter(f=>f && (f.type?.startsWith("audio/") || /\.(wav|mp3|ogg|m4a|flac)$/i.test(f.name||"")));
  if(!list.length) return;

  exportCancelRequested = false;
  exportShow(`Samples laden… 0/${list.length}`, 10);

  for(let i=0;i<list.length;i++){
    if(exportCancelRequested) throw new Error("Export cancelled");
    const file = list[i];

    exportShow(`Sample laden… ${i+1}/${list.length}\n${file.name || ""}`, 10 + 45*(i/list.length));
    await new Promise(r=>setTimeout(r, 0));

    const buf = await decodeAudioFileToBuffer(file);

    // For each sample: use 10 random seconds, spread over 10% of sequence
    applySampleShuffleMulti(buf, file.name || "sample", 10);

    exportShow(`Geplaatst… ${i+1}/${list.length}`, 10 + 45*((i+1)/list.length));
    await new Promise(r=>setTimeout(r, 0));
  }

  closeDropdown();
  buildGrid();
  scheduleSave(true);
  exportShow("Klaar!", 100);
  setTimeout(()=>exportHide(), 700);
  setStatus(`shuffle sample: ${list.length} file(s)`);
}

if(shuffleSampleBtn && shuffleSampleFile){
  shuffleSampleBtn.addEventListener("click", ()=>{
    // Browser security: user must pick files/directory via picker.
    shuffleSampleFile.value = "";
    shuffleSampleFile.click();
  });

  shuffleSampleFile.addEventListener("change", async ()=>{
    const fileList = shuffleSampleFile.files ? Array.from(shuffleSampleFile.files) : [];
    // Don't clear before we copy list (some browsers lose it)
    shuffleSampleFile.value = "";
    if(!fileList.length) { setStatus("no files selected"); return; }

    try{
      setStatus(`loading ${fileList.length} sample(s)…`);
      await applyDirectoryOrMultiShuffle(fileList);
    }catch(e){
      exportHide();
      showError(e);
      setStatus("sample load failed");
    }
  });
}

// ---------- Scale all frequencies to 10..100 Hz ----------
        document.getElementById("scale10100").addEventListener("click", ()=>{
          const minHz = 10;
          const maxHz = 100;

          // find current min/max among all cells (finite freqs)
          let fMin = Infinity;
          let fMax = -Infinity;

          for(let r=0;r<gridData.length;r++){
            for(let c=0;c<gridData[r].length;c++){
              const f = Number(gridData[r][c].freq);
              if(Number.isFinite(f)){
                if(f < fMin) fMin = f;
                if(f > fMax) fMax = f;
              }
            }
          }

          const hasRange = Number.isFinite(fMin) && Number.isFinite(fMax);
          const span = hasRange ? (fMax - fMin) : 0;

          for(let r=0;r<gridData.length;r++){
            for(let c=0;c<gridData[r].length;c++){
              const cell = gridData[r][c];
              const f = Number(cell.freq);
              if(!Number.isFinite(f)) continue;

              let mapped;
              if(span <= 0.0000001){
                mapped = (minHz + maxHz) / 2;
              } else {
                mapped = minHz + ((f - fMin) * (maxHz - minHz)) / span;
              }
              cell.freq = Number(Math.max(minHz, Math.min(maxHz, mapped)).toFixed(2));
            }
          }

          // if dropdown is open, refresh its freq UI
          try{
            if(dropdownOpenFor){
              const { r, c } = dropdownOpenFor;
              if(gridData[r] && gridData[r][c]) setFreqUI(gridData[r][c].freq);
            }
          }catch{}

          closeDropdown();
          buildGrid();
          scheduleSave(true);
          setStatus("scaled 20-100");
        });


        // ---------- WebMIDI OUT ----------
        let midiAccess = null;
        let midiOut = null;

        const midiOutSelect = document.getElementById("midiOutSelect");
        const midiRefreshBtn = document.getElementById("midiRefresh");
        const midiSendMode = document.getElementById("midiSendMode");
        const midiOverrideCh = document.getElementById("midiOverrideCh");

        function updateOverrideVisibility(){
          midiOverrideCh.style.display = (midiSendMode.value === "override") ? "" : "none";
        }
        midiSendMode.addEventListener("change", ()=>{ updateOverrideVisibility(); scheduleSave(); });
        midiOverrideCh.addEventListener("change", ()=> scheduleSave());
        updateOverrideVisibility();

        function restoreMidiOutByIdWithRetry(outId, tries = 40, delayMs = 200) {
          if (!outId) return;
          let n = 0;
          const t = setInterval(() => {
            n++;
            if (midiAccess && midiAccess.outputs) {
              const out = midiAccess.outputs.get(outId);
              if (out) {
                midiOutSelect.value = outId;
                midiOut = out;
                setStatus("MIDI out restored");
                clearInterval(t);
              }
            }
            if (n >= tries) clearInterval(t);
          }, delayMs);
        }

        async function initMIDI(){
          midiOutSelect.innerHTML = `<option value="">(geen)</option>`;
          midiOut = null;
          midiAccess = null;

          if(!navigator.requestMIDIAccess){
            setStatus("WebMIDI not supported");
            return;
          }
          try{
            midiAccess = await navigator.requestMIDIAccess({ sysex:false });
            const outs = Array.from(midiAccess.outputs.values());
            for(const o of outs){
              const opt = document.createElement("option");
              opt.value = o.id;
              opt.textContent = o.name || `MIDI Out (${o.id})`;
              midiOutSelect.appendChild(opt);
            }
            setStatus(outs.length ? "MIDI ready" : "no MIDI outputs");

            midiOutSelect.onchange = () => {
              const id = midiOutSelect.value;
              midiOut = id ? midiAccess.outputs.get(id) : null;
              setStatus(midiOut ? "MIDI out selected" : "MIDI out none");
              scheduleSave();
            };

            // Restore from autosave
            try{
              const raw = localStorage.getItem(STORAGE_KEY);
              if(raw){
                const st = JSON.parse(raw);
                const outId = st?.midi?.outId || "";
                if(outId) restoreMidiOutByIdWithRetry(outId);
              }
            }catch{}

            midiAccess.onstatechange = () => { initMIDI(); };
          }catch(e){
            console.warn(e);
            setStatus("MIDI denied");
          }
        }
        midiRefreshBtn.addEventListener("click", initMIDI);
        initMIDI();

        function midiSend(bytes){
          if(!midiOut) return;
          try{ midiOut.send(bytes); }catch{}
        }
        function midiNoteOn(ch1to16, note, vel){
          const ch = clampInt(ch1to16,1,16) - 1;
          midiSend([0x90 | ch, clampInt(note,0,127), clampInt(vel,0,127)]);
        }
        function midiNoteOff(ch1to16, note, vel=0){
          const ch = clampInt(ch1to16,1,16) - 1;
          midiSend([0x80 | ch, clampInt(note,0,127), clampInt(vel,0,127)]);
        }
        function midiCC(ch1to16, cc, val){
          const ch = clampInt(ch1to16,1,16) - 1;
          midiSend([0xB0 | ch, clampInt(cc,0,127), clampInt(val,0,127)]);
        }
        function midiProgram(ch1to16, prog){
          const ch = clampInt(ch1to16,1,16) - 1;
          midiSend([0xC0 | ch, clampInt(prog,0,127)]);
        }
        function midiPitchBend(ch1to16, value){
          const ch = clampInt(ch1to16,1,16) - 1;
          const v = clampInt(value, -8192, 8191) + 8192;
          const lsb = v & 0x7F;
          const msb = (v >> 7) & 0x7F;
          midiSend([0xE0 | ch, lsb, msb]);
        }

// ---- MIDI Vibrato LFO (PitchBend) ----
function startMidiVibrato(){
  if(midiVibratoTimer) return;
  const intervalMs = 1000 / 60; // ~60 FPS
  midiVibratoTimer = setInterval(()=>{
    // advance phase
    midiVibratoPhase += (2 * Math.PI * midiVibratoRate) * (intervalMs / 1000);
    // compute bend (-depth..+depth)
    const bend = Math.sin(midiVibratoPhase) * midiVibratoDepth;

    // Apply to all currently active note channels
    for(const key of prevActiveNoteKeys){
      const ch = Number(String(key).split(":")[0]);
      if(Number.isFinite(ch)) midiPitchBend(ch, bend);
    }
  }, intervalMs);
}

function stopMidiVibrato(){
  if(!midiVibratoTimer) return;
  clearInterval(midiVibratoTimer);
  midiVibratoTimer = null;
  midiVibratoPhase = 0;

  // Reset pitch bend to center on all channels (safe)
  for(let ch=1; ch<=16; ch++){
    midiPitchBend(ch, 0);
  }
}

        function midiAllNotesOff(){
          for(let ch=0; ch<16; ch++) midiSend([0xB0 | ch, 123, 0]);
        }
        function effectiveChannels(cellCh){
          const mode = midiSendMode.value;
          if(mode === "per_cell") return [clampInt(cellCh,1,16)];
          if(mode === "override") return [clampInt(midiOverrideCh.value,1,16)];
          return Array.from({length:16}, (_,i)=> i+1);
        }

        let prevActiveNoteKeys = new Set(); // `${ch}:${note}`

        // ---- MIDI vibrato (max) ----
        // NOTE: MIDI vibrato is implemented as a PitchBend LFO (works on most synths).
        // Depth is in PitchBend units (-8192..8191). 8191 = MAX.
        let midiVibratoEnabled = true;
        let midiVibratoDepth = 8191; // MAX vibrato
        let midiVibratoRate = 8;     // Hz (6–10 is typical)
        let midiVibratoTimer = null;
        let midiVibratoPhase = 0;


        function stepMidiDispatch(r){
          if(!midiOut) return;
          const curActiveNoteKeys = new Set();

          for(let c=0;c<COLS;c++){
            if(!gridOn[r][c]) continue;
            const cell = gridData[r][c];
            if(!cell.midi || !cell.midi.enable) continue;

            const channels = effectiveChannels(cell.midi.ch);
            const cmd = cell.midi.cmd || "note";

            if(cmd === "note"){
              const note = clampInt(cell.midi.note,0,127);
              const vel  = clampInt(cell.midi.vel,0,127);

              for(const ch of channels){
                const key = `${ch}:${note}`;
                curActiveNoteKeys.add(key);
                if(!prevActiveNoteKeys.has(key)) midiNoteOn(ch, note, vel);
              }
            } else if(cmd === "cc") {
              const ccN = clampInt(cell.midi.ccN,0,127);
              const ccV = clampInt(cell.midi.ccV,0,127);
              for(const ch of channels) midiCC(ch, ccN, ccV);
            } else if(cmd === "program") {
              const prog = clampInt(cell.midi.program,0,127);
              for(const ch of channels) midiProgram(ch, prog);
            } else if(cmd === "pitchbend") {
              const pb = clampInt(cell.midi.pitchbend,-8192,8191);
              for(const ch of channels) midiPitchBend(ch, pb);
            }
          }

          for(const key of prevActiveNoteKeys){
            if(!curActiveNoteKeys.has(key)){
              const [chStr, noteStr] = key.split(":");
              midiNoteOff(Number(chStr), Number(noteStr), 0);
            }
          }
// Vibrato: run PitchBend LFO only when at least one MIDI note is active

if(midiVibratoEnabled && curActiveNoteKeys.size > 0) {

  startMidiVibrato();

} else {

  stopMidiVibrato();

}


          prevActiveNoteKeys = curActiveNoteKeys;
        }

        // ============================================================
        // ===================== FX CHAIN (15) =========================
        // ============================================================
        // createFXChain(ctx, fxSettings, inputNode) -> { out, cleanup? }
        // NOTE: bitcrush uses ScriptProcessor (works live, skipped in Offline export)
        function createFXChain(ctx, fx, input){
          const type = (fx && fx.type) ? String(fx.type) : "none";
          const p1 = (fx && Number.isFinite(fx.p1)) ? fx.p1 : 0.5;
          const p2 = (fx && Number.isFinite(fx.p2)) ? fx.p2 : 0.5;

          // pass-through helper
          const pass = { out: input, cleanup: ()=>{} };

          if(type === "none") return pass;

          if(type === "delay"){
            const delay = ctx.createDelay(2.0);
            delay.delayTime.value = clamp(p1, 0, 2.0);
            const fb = ctx.createGain();
            fb.gain.value = clamp(p2, 0, 0.95);
            input.connect(delay);
            delay.connect(fb);
            fb.connect(delay);
            return { out: delay, cleanup: ()=>{ try{ delay.disconnect(); fb.disconnect(); }catch{} } };
          }

          if(type === "reverb"){
            // Shared convolution reverb (mathematically identical for linear convolver, but far cheaper for export)
            const convolver = getSharedConvolver(ctx, 2.0, 2.0 * p1);
            // --- centered reverb feed (mono-sum then duplicate to stereo) ---

            const split = ctx.createChannelSplitter(2);

            const sum = ctx.createGain();

            sum.gain.value = 0.5; // avoid +6dB when summing L+R

            const merge = ctx.createChannelMerger(2);

            input.connect(split);

            split.connect(sum, 0);

            split.connect(sum, 1);

            // duplicate mono into both L and R of the convolver input

            sum.connect(merge, 0, 0);

            sum.connect(merge, 0, 1);

            merge.connect(convolver);
return { out: convolver, cleanup: ()=>{} };
          }


          if(type === "vibpanreverb"){
            // Composite: vibrato (LFO -> detune) + random/param pan + reverb
            // p1 controls vibrato depth (0..1), p2 controls reverb amount (0..1). Pan comes from fx.pan (-1..1) or 0.
            const panVal = (fx && Number.isFinite(fx.pan)) ? clamp(fx.pan, -1, 1) : 0;

            // Vibrato via detune (cents)
            const lfo = ctx.createOscillator();
            lfo.type = "sine";
            const lfoGain = ctx.createGain();
            // "max vibrato": depth up to 1200 cents (1 octave) when p1=1
            lfoGain.gain.value = 1200 * clamp(p1, 0, 1) * 0.03125; // vibpanreverb intensity 1/32
            lfo.frequency.value = 12 + 8 * clamp(p1, 0, 1) * 0.03125; // slower vibrato (1/32) // 12..20 Hz

            // We need a target node with detune param; create a Gain as passthrough and connect later in voice creation
            // Here we assume input is the source node (osc or buffer source) and has .detune param when used.
            if(input && input.detune){
              lfo.connect(lfoGain);
              lfoGain.connect(input.detune);
              lfo.start();
            }

            const panner = ctx.createStereoPanner();
            panner.pan.value = panVal;

            const convolver = getSharedConvolver(ctx, 2.0, 2.0 * 0.05); // vibpanreverb reverb fixed at 5%
            // routing: input -> panner -> convolver -> out
            input.connect(panner);
            panner.connect(convolver);

            return { out: convolver, cleanup: ()=>{ try{ convolver.disconnect(); panner.disconnect(); lfoGain.disconnect(); lfo.disconnect(); }catch{} } };
          }


          if(type === "chorus"){
            const delay = ctx.createDelay(0.05);
            delay.delayTime.value = 0.02;
            const lfo = ctx.createOscillator();
            lfo.type = "sine";
            lfo.frequency.value = 0.2 + 4*p1;
            const lfoGain = ctx.createGain();
            lfoGain.gain.value = 0.002 + 0.02*p2;
            lfo.connect(lfoGain);
            lfoGain.connect(delay.delayTime);
            input.connect(delay);
            lfo.start();
            return { out: delay, cleanup: ()=>{ try{ lfo.stop(); lfo.disconnect(); lfoGain.disconnect(); delay.disconnect(); }catch{} } };
          }

          if(type === "flanger"){
            const delay = ctx.createDelay(0.02);
            delay.delayTime.value = 0.005;
            const fb = ctx.createGain();
            fb.gain.value = 0.2 + 0.7*p2;
            const lfo = ctx.createOscillator();
            lfo.frequency.value = 0.1 + 5*p1;
            const lfoGain = ctx.createGain();
            lfoGain.gain.value = 0.001 + 0.008*p2;
            lfo.connect(lfoGain);
            lfoGain.connect(delay.delayTime);
            input.connect(delay);
            delay.connect(fb);
            fb.connect(delay);
            lfo.start();
            return { out: delay, cleanup: ()=>{ try{ lfo.stop(); lfo.disconnect(); lfoGain.disconnect(); fb.disconnect(); delay.disconnect(); }catch{} } };
          }

          if(type === "phaser"){
            const ap1 = ctx.createBiquadFilter(); ap1.type="allpass"; ap1.frequency.value = 300;
            const ap2 = ctx.createBiquadFilter(); ap2.type="allpass"; ap2.frequency.value = 800;
            const lfo = ctx.createOscillator(); lfo.frequency.value = 0.1 + 3*p1;
            const lfoGain = ctx.createGain(); lfoGain.gain.value = 200 + 1200*p2;
            lfo.connect(lfoGain);
            lfoGain.connect(ap1.frequency);
            lfoGain.connect(ap2.frequency);
            input.connect(ap1);
            ap1.connect(ap2);
            lfo.start();
            return { out: ap2, cleanup: ()=>{ try{ lfo.stop(); lfo.disconnect(); lfoGain.disconnect(); ap1.disconnect(); ap2.disconnect(); }catch{} } };
          }

          if(type === "tremolo"){
            const gain = ctx.createGain();
            gain.gain.value = 1.0;
            const lfo = ctx.createOscillator(); lfo.type="sine"; lfo.frequency.value = 0.5 + 12*p1;
            const depth = ctx.createGain(); depth.gain.value = clamp(p2,0,1);
            // create offset: (1 - depth) + depth * sin
            const offset = ctx.createConstantSource(); offset.offset.value = 1 - depth.gain.value;
            lfo.connect(depth);
            depth.connect(gain.gain);
            offset.connect(gain.gain);
            input.connect(gain);
            offset.start();
            lfo.start();
            return { out: gain, cleanup: ()=>{ try{ lfo.stop(); offset.stop(); lfo.disconnect(); depth.disconnect(); offset.disconnect(); gain.disconnect(); }catch{} } };
          }

          if(type === "vibrato"){
            // vibrato = lfo to pitch
            // We'll approximate with Delay modulation (very small) to avoid direct oscillator pitch coupling
            const delay = ctx.createDelay(0.02);
            delay.delayTime.value = 0.004;
            const lfo = ctx.createOscillator(); lfo.frequency.value = 0.5 + 10*p1;
            const lfoGain = ctx.createGain(); lfoGain.gain.value = 0.0002 + 0.003*p2;
            lfo.connect(lfoGain);
            lfoGain.connect(delay.delayTime);
            input.connect(delay);
            lfo.start();
            return { out: delay, cleanup: ()=>{ try{ lfo.stop(); lfo.disconnect(); lfoGain.disconnect(); delay.disconnect(); }catch{} } };
          }

          if(type === "distortion"){
            const ws = ctx.createWaveShaper();
            ws.curve = makeDistCurve(20 + 600*p1);
            ws.oversample = "4x";
            input.connect(ws);
            return { out: ws, cleanup: ()=>{ try{ ws.disconnect(); }catch{} } };
          }

          if(type === "bitcrush"){
            // live-only (ScriptProcessor). Offline export bypasses bitcrush.
            if(typeof ctx.createScriptProcessor !== "function") return pass;
            const sp = ctx.createScriptProcessor(1024, 1, 1);
            const crush = Math.floor(2 + 14*(1-p1)); // lower p1 => more crush
            const step = Math.pow(0.5, crush);
            let ph = 0, last = 0;
            sp.onaudioprocess = (e)=>{
              const inputBuf = e.inputBuffer.getChannelData(0);
              const outBuf = e.outputBuffer.getChannelData(0);
              for(let i=0;i<inputBuf.length;i++){
                ph += step;
                if(ph >= 1.0){ ph -= 1.0; last = inputBuf[i]; }
                outBuf[i] = last;
              }
            };
            input.connect(sp);
            return { out: sp, cleanup: ()=>{ try{ sp.disconnect(); }catch{} } };
          }

          if(type === "compressor"){
            const comp = ctx.createDynamicsCompressor();
            comp.threshold.value = -24 - 30*p1;
            comp.ratio.value = 2 + 18*p2;
            input.connect(comp);
            return { out: comp, cleanup: ()=>{ try{ comp.disconnect(); }catch{} } };
          }

          if(type === "limiter"){
            const comp = ctx.createDynamicsCompressor();
            comp.threshold.value = -10;
            comp.knee.value = 0;
            comp.ratio.value = 20;
            comp.attack.value = 0.003;
            comp.release.value = 0.08;
            input.connect(comp);
            return { out: comp, cleanup: ()=>{ try{ comp.disconnect(); }catch{} } };
          }

          if(type === "pan"){
            if(typeof ctx.createStereoPanner !== "function") return pass;
            const pan = ctx.createStereoPanner();
            pan.pan.value = clamp((p1*2)-1, -1, 1);
            input.connect(pan);
            return { out: pan, cleanup: ()=>{ try{ pan.disconnect(); }catch{} } };
          }

          if(type === "ringmod"){
            const mod = ctx.createOscillator();
            mod.type="sine";
            mod.frequency.value = 20 + 2000*p1;
            const modGain = ctx.createGain();
            modGain.gain.value = clamp(p2, 0, 1);
            const outGain = ctx.createGain();
            outGain.gain.value = 0;
            input.connect(outGain);
            mod.connect(modGain);
            modGain.connect(outGain.gain);
            mod.start();
            return { out: outGain, cleanup: ()=>{ try{ mod.stop(); mod.disconnect(); modGain.disconnect(); outGain.disconnect(); }catch{} } };
          }

          if(type === "wah"){
            const f = ctx.createBiquadFilter();
            f.type = "bandpass";
            f.Q.value = 3 + 20*p2;
            const lfo = ctx.createOscillator();
            lfo.type="sine";
            lfo.frequency.value = 0.2 + 6*p1;
            const lfoGain = ctx.createGain();
            lfoGain.gain.value = 200 + 1500*p2;
            const base = ctx.createConstantSource();
            base.offset.value = 300 + 700*p1;
            lfo.connect(lfoGain);
            lfoGain.connect(f.frequency);
            base.connect(f.frequency);
            input.connect(f);
            base.start();
            lfo.start();
            return { out: f, cleanup: ()=>{ try{ lfo.stop(); base.stop(); lfo.disconnect(); lfoGain.disconnect(); base.disconnect(); f.disconnect(); }catch{} } };
          }

          return pass;
        }

        function makeImpulse(ctx, seconds, decay){
          // Cached impulse buffers to avoid allocating big buffers per voice (prevents crashes on mobile)
          const rate = ctx.sampleRate || 44100;
          if(!makeImpulse._cache) makeImpulse._cache = new WeakMap();
          let ctxMap = makeImpulse._cache.get(ctx);
          if(!ctxMap){
            ctxMap = new Map();
            makeImpulse._cache.set(ctx, ctxMap);
          }
          const s = Math.max(0.01, Number(seconds) || 0.01);
          const d = Math.max(0.01, Number(decay) || 0.01);
          const key = rate + "|" + s.toFixed(3) + "|" + d.toFixed(3);
          if(ctxMap.has(key)) return ctxMap.get(key);

          const len = Math.max(1, Math.floor(s * rate));
          const buf = ctx.createBuffer(2, len, rate);
          for(let ch=0; ch<2; ch++){
            const data = buf.getChannelData(ch);
            for(let i=0; i<len; i++){
              const t = i / len;
              data[i] = (Math.random()*2 - 1) * Math.pow(1 - t, d);
            }
          }
          ctxMap.set(key, buf);
          return buf;
        }

        function getSharedConvolver(ctx, seconds, decay){
          // Share ConvolverNodes per context+impulse to avoid creating hundreds of convolvers during WAV export.
          if(!getSharedConvolver._cache) getSharedConvolver._cache = new WeakMap();
          let ctxMap = getSharedConvolver._cache.get(ctx);
          if(!ctxMap){
            ctxMap = new Map();
            getSharedConvolver._cache.set(ctx, ctxMap);
          }
          const rate = ctx.sampleRate || 44100;
          const s = Math.max(0.01, Number(seconds) || 0.01);
          const d = Math.max(0.01, Number(decay) || 0.01);
          const key = rate + "|" + s.toFixed(3) + "|" + d.toFixed(3);
          if(ctxMap.has(key)) return ctxMap.get(key);

          const conv = ctx.createConvolver();
          conv.normalize = true;
          conv.buffer = makeImpulse(ctx, s, d);
          ctxMap.set(key, conv);
          return conv;
        }
        function makeDistCurve(amount){
          const k = Math.max(1, amount);
          const n = 44100;
          const curve = new Float32Array(n);
          for(let i=0;i<n;i++){
            const x = (i*2/n)-1;
            curve[i] = (1 + k) * x / (1 + k * Math.abs(x));
          }
          return curve;
        }

        // ---------- audio voices ----------
        const activeVoices = new Map(); // hold per column -> {osc/src, gain, fxCleanup}
        let holdVoice = null;
        let isHolding = false;
        let holdRestarting = false;
        let previewMode = "wet"; // wet/dry A/B audition

        function holdKeyForCol(c){ return `col:${c}`; }

        function cellParamsSig(cell){
          const src = String(cell.source || 'osc');
          const f = Number(cell.freq)||0;
          const w = String(cell.wave||'sine');
          const ft = String(cell.filter?.type||'none');
          const ff = Number(cell.filter?.frequency||0);
          const fq = Number(cell.filter?.Q||0);
          const fg = Number(cell.filter?.gain||0);
          const fxType = String(cell.fx?.type||'none');
          const fxAmt  = Number(cell.fx?.amount||0);
          const samp = String(cell.sample?.url||'');
          return `${src}|${f.toFixed(4)}|${w}|${ft}|${ff}|${fq}|${fg}|${fxType}|${fxAmt}|${samp}`;
        }


        

function cellParamsSigNoFreq(cell){
  const src = String(cell.source || 'osc');
  const w = String(cell.wave||'sine');
  const ft = String(cell.filter?.type||'none');
  const ff = Number(cell.filter?.frequency||0);
  const fq = Number(cell.filter?.Q||0);
  const fg = Number(cell.filter?.gain||0);
  const fxType = String(cell.fx?.type||'none');
  const fxAmt  = Number(cell.fx?.amount||0);
  const samp = String(cell.sample?.url||'');
  return `${src}|${w}|${ft}|${ff}|${fq}|${fg}|${fxType}|${fxAmt}|${samp}`;
}

// --- Sample voice limiter (prevents crackle from too many overlapping short/deep hits) ---
const MAX_SAMPLE_VOICES = 16; // safer on mobile, especially with heavy visuals
let _activeSampleVoices = []; // {src, tEnd}

function _registerSampleVoice(src, tEnd){
  try{
    _activeSampleVoices.push({ src, tEnd });
    while(_activeSampleVoices.length > MAX_SAMPLE_VOICES){
      const v = _activeSampleVoices.shift();
      try{ v.src.stop(); }catch{}
    }
    const now = audioCtx.currentTime || 0;
    _activeSampleVoices = _activeSampleVoices.filter(v=> v && v.src && (v.tEnd == null || v.tEnd > now - 0.25));
  }catch{}
}
        async function playOneShot(cell, durSec){
          if(audioCtx.state==="suspended") await audioCtx.resume();
          const now = audioCtx.currentTime;
          const stepDur = Math.max(0.02, durSec);

          const gain = audioCtx.createGain();
          gain.gain.setValueAtTime(0, now);

          // FX
          const fxChain = { out: gain, cleanup: ()=>{} }; // step-FX disabled (use Master FX)
          fxChain.out.connect(masterGain);

          if(cell.source === "sample" && cell.sample && cell.sample.url){
            const buf = sampleCache.get(cell.sample.url);
            if(!buf) return;
            const src = audioCtx.createBufferSource();
            src.buffer = buf;
// DC blocker / anti-thump
const hp = audioCtx.createBiquadFilter();
hp.type = "highpass";
hp.frequency.value = 30;
hp.Q.value = 0.707;

src.connect(hp);
hp.connect(gain);

            // Pitch shift for "Sample→MIDI" (rootNote → targetNote). Defaults to no shift.
            try{
              const root = clampInt((cell.sample && cell.sample.rootNote!=null) ? cell.sample.rootNote : 60, 0, 127);
              const tgt  = clampInt((cell.sample && cell.sample.targetNote!=null) ? cell.sample.targetNote : root, 0, 127);
              const semis = tgt - root;
              const rate = clamp(Math.pow(2, semis/12), 0.125, 8);
              src.playbackRate.setValueAtTime(rate, now);
            }catch{}

            const A_in = Math.max(0, getEffectiveADSR(cell).a);
          const A_click = Math.max(CLICK_FADE, A_in);
            const D_in = Math.max(0, getEffectiveADSR(cell).d);
            const S = clamp(Number(cell.adsr.s)||0, 0, 10);
            const R_in = Math.max(0, getEffectiveADSR(cell).r);

            // Optional duration override (used by Sample→MIDI so longer notes can ring out)
            let playWindowSec = stepDur * (1 + (glideEnabled ? overlapRatio : 0));
            const od = (cell.sample && Number.isFinite(cell.sample.noteDurSec)) ? Number(cell.sample.noteDurSec) : NaN;
            if(Number.isFinite(od) && od > 0) playWindowSec = Math.max(stepDur, od);

            const R = Math.max(EPS, Math.min(playWindowSec*0.98, Math.max(EPS, R_in)));
            const tEnd = now + playWindowSec;
            const tRelStart = Math.max(now, tEnd - R);

            const maxAD = Math.max(EPS, tRelStart - now);
            const A = Math.min(Math.max(EPS, A_click), maxAD);
            const D = Math.min(Math.max(EPS, D_in), Math.max(EPS, maxAD - A));

            const tA = now + A;
            const tD = tA + D;

            const peak = 0.6;
            const sustainLevel = Math.max(0, Math.min(1, peak * (S / 10)));

            gain.gain.cancelScheduledValues(now);
            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(Math.max(EPS, peak), tA);
            gain.gain.linearRampToValueAtTime(Math.max(EPS, sustainLevel), tD);
            gain.gain.setValueAtTime(Math.max(EPS, sustainLevel), tRelStart);
            gain.gain.linearRampToValueAtTime(0, tEnd);

            // sample slice: start + length in %
            const dur = buf.duration || 0;
            const sp = clamp(Number(cell.sample?.startPct ?? 0), 0, 100);
            const lp = clamp(Number(cell.sample?.lengthPct ?? 100), 0.01, 100);
            const startSec = dur * (sp / 100);
            const playSec = dur * (lp / 100);
            const safePlay = Math.max(0.001, Math.min(playSec, Math.max(0.001, dur - startSec)));
            

// Anti-click fade for sample playback (adaptive ramps; better for short/deep hits)
try{
  const FADE_MIN = 0.020; // 20ms (helps bass clicks)
  const FADE_MAX = 0.080; // 80ms cap
  const FADE = Math.max(FADE_MIN, Math.min(FADE_MAX, safePlay * 0.25, STEP_FADE * 2));

  gain.gain.cancelScheduledValues(now);
  gain.gain.setValueAtTime(0, now);
  gain.gain.linearRampToValueAtTime(1.0, now + FADE);

  const holdT = Math.max(now + FADE, tEnd - FADE);
  gain.gain.setValueAtTime(1.0, holdT);
  gain.gain.linearRampToValueAtTime(0.00001, tEnd);
}catch{}
src.start(now, startSec, safePlay);
            src.stop(tEnd + STEP_FADE + 0.01);

                        _registerSampleVoice(src, tEnd + STEP_FADE + 0.01);
src.onended = () => {
              try{ src.disconnect(); }catch{}
              try{ fxChain.cleanup && fxChain.cleanup(); }catch{}
              try{ gain.disconnect(); }catch{}
            };
            return;
          }

          // oscillator
          const osc = audioCtx.createOscillator();
          osc.type = cell.wave;
          osc.frequency.setValueAtTime(Math.max(1, Number(cell.freq)||440), now);
          osc.connect(gain);

          const A_in = Math.max(0, getEffectiveADSR(cell).a);
          const A_click = Math.max(CLICK_FADE, A_in);
          const D_in = Math.max(0, getEffectiveADSR(cell).d);
          const S = clamp(Number(cell.adsr.s)||0, 0, 10);
          const R_in = Math.max(0, getEffectiveADSR(cell).r);

          const R = Math.max(EPS, Math.min(stepDur*0.98, Math.max(EPS, R_in)));
          const tEnd = now + stepDur * (1 + (glideEnabled ? overlapRatio : 0));
          const tRelStart = Math.max(now, tEnd - R);

          const maxAD = Math.max(EPS, tRelStart - now);
          const A = Math.min(Math.max(EPS, A_click), maxAD);
          const D = Math.min(Math.max(EPS, D_in), Math.max(EPS, maxAD - A));

          const tA = now + A;
          const tD = tA + D;

          const peak = 0.22;
          const sustainLevel = Math.max(0, Math.min(1, peak * (S / 10)));

          gain.gain.cancelScheduledValues(now);
          gain.gain.setValueAtTime(0, now);
          gain.gain.linearRampToValueAtTime(Math.max(EPS, peak), tA);
          gain.gain.linearRampToValueAtTime(Math.max(EPS, sustainLevel), tD);
          gain.gain.setValueAtTime(Math.max(EPS, sustainLevel), tRelStart);
          gain.gain.linearRampToValueAtTime(0, tEnd);

          osc.start(now);
          osc.stop(tEnd + 0.02);

          osc.onended = () => {
            try{ osc.disconnect(); }catch{}
            try{ fxChain.cleanup && fxChain.cleanup(); }catch{}
            try{ gain.disconnect(); }catch{}
          };
        }

        async function startOrKeepHoldVoice(colKey, cell){
          if(audioCtx.state==="suspended") await audioCtx.resume();

          const sig = cellParamsSig(cell);
          const existing = activeVoices.get(colKey);
          if(existing){
            if(existing.paramsSig === sig) return;

            // Glide: if we already have an OSC hold voice with the same "non-pitch" params,
            // then we can smoothly retune without retriggering the envelope.
            try{
              if(glideEnabled && existing.osc && existing.paramsSigNoFreq && existing.paramsSigNoFreq === cellParamsSigNoFreq(cell)){
                const now2 = audioCtx.currentTime;
                const newF = Math.max(1, Number(cell.freq)||440);
                // Cancel any old ramps and glide to the new pitch
                try{ existing.osc.frequency.cancelScheduledValues(now2); }catch{}
                try{ existing.osc.frequency.setValueAtTime(Math.max(1, existing.osc.frequency.value||newF), now2); }catch{}
                if(glideTimeSec > 0){
                  try{ existing.osc.frequency.linearRampToValueAtTime(newF, now2 + Math.min(1.5, glideTimeSec)); }catch{}
                }else{
                  try{ existing.osc.frequency.setValueAtTime(newF, now2); }catch{}
                }
                existing.paramsSig = sig;
                return;
              }
            }catch{}

            stopHoldVoice(colKey, cell, true); // params changed -> fast release
          }

          const now = audioCtx.currentTime;
          const gain = audioCtx.createGain();
          gain.gain.setValueAtTime(0, now);

          // FX
          const fxChain = { out: gain, cleanup: ()=>{} }; // step-FX disabled (use Master FX)
          fxChain.out.connect(masterGain);

          // sample hold
          if(cell.source === "sample" && cell.sample && cell.sample.url){
            const buf = sampleCache.get(cell.sample.url);
            if(!buf) return;

            const src = audioCtx.createBufferSource();
            src.buffer = buf;
            src.loop = true;
// DC blocker / anti-thump
const hp = audioCtx.createBiquadFilter();
hp.type = "highpass";
hp.frequency.value = 25;
hp.Q.value = 0.707;

src.connect(hp);
hp.connect(gain);

            const A0 = Math.max(EPS, getEffectiveADSR(cell).a);
            const D0 = Math.max(EPS, getEffectiveADSR(cell).d);
            const S  = clamp(getEffectiveADSR(cell).s, 0, 10);

            const peak = 0.6;
            const sustainLevel = Math.max(0, Math.min(1, peak * (S / 10)));

            const A = Math.max(CLICK_FADE, A0);
            const D = Math.max(CLICK_FADE, D0);

            gain.gain.cancelScheduledValues(now);
            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(Math.max(EPS, peak), now + A);
            gain.gain.linearRampToValueAtTime(Math.max(EPS, sustainLevel), now + A + D);
            gain.gain.setValueAtTime(Math.max(EPS, sustainLevel), now + A + D + 0.0001);

            src.start(now);
            activeVoices.set(colKey, { src, gain, fxChain, paramsSig: sig });
            return;
          }

          // osc hold
          const osc = audioCtx.createOscillator();
          osc.type = cell.wave;
          osc.frequency.setValueAtTime(Math.max(1, Number(cell.freq)||440), now);

          let filterNode = null;
          if(cell.filter?.type && cell.filter.type !== "none"){
            filterNode = audioCtx.createBiquadFilter();
            filterNode.type = cell.filter.type;
            const f = Math.max(0, Math.min(20000, Number(cell.filter.frequency)||1200));
            const q = Math.max(0.00001, Number(cell.filter.Q)||1);
            const g = Number(cell.filter.gain)||0;
            filterNode.frequency.setValueAtTime(f, now);
            filterNode.Q.setValueAtTime(q, now);
            filterNode.gain.setValueAtTime(g, now);
          }

          if(filterNode){ osc.connect(filterNode); filterNode.connect(gain); }
          else { osc.connect(gain); }

          const A0 = Math.max(EPS, getEffectiveADSR(cell).a);
          const D0 = Math.max(EPS, getEffectiveADSR(cell).d);
          const S  = clamp(getEffectiveADSR(cell).s, 0, 10);

          const peak = 0.6;
          const sustainLevel = Math.max(0, Math.min(1, peak * (S / 10)));

          const A = Math.max(CLICK_FADE, A0);
          const D = Math.max(CLICK_FADE, D0);

          gain.gain.cancelScheduledValues(now);
          gain.gain.setValueAtTime(0, now);
          gain.gain.linearRampToValueAtTime(Math.max(EPS, peak), now + A);
          gain.gain.linearRampToValueAtTime(Math.max(EPS, sustainLevel), now + A + D);
          gain.gain.setValueAtTime(Math.max(EPS, sustainLevel), now + A + D + 0.0001);

          osc.start(now);
          activeVoices.set(colKey, { osc, gain, filterNode, fxChain, paramsSig: sig, paramsSigNoFreq: cellParamsSigNoFreq(cell) });
        }

        function stopHoldVoice(colKey, cellForRelease, fast=false){
          const v = activeVoices.get(colKey);
          if(!v) return;

          const now = audioCtx.currentTime;
          const R_in = Number(cellForRelease?.adsr?.r ?? 0.2);
          const R = Math.max(EPS, fast ? Math.min(0.06, R_in || 0.06) : Math.max(EPS, R_in || 0.2));
          const rel = Math.max(CLICK_FADE, R);

          try{
            v.gain.gain.cancelScheduledValues(now);
            const cur = Math.max(EPS, v.gain.gain.value || EPS);
            v.gain.gain.setValueAtTime(cur, now);
            v.gain.gain.linearRampToValueAtTime(0, now + rel);
          }catch{}

          try{ if(v.osc) v.osc.stop(now + rel + 0.03); }catch{}
          try{ if(v.src) v.src.stop(now + rel + 0.03); }catch{}

          const node = v.osc || v.src;
          if(node){
            node.onended = () => {
              try{ node.disconnect(); }catch{}
              try{ if(v.filterNode) v.filterNode.disconnect(); }catch{}
              try{ v.fxChain?.cleanup && v.fxChain.cleanup(); }catch{}
              try{ v.gain.disconnect(); }catch{}
            };
          }

          activeVoices.delete(colKey);
        }

        // ---------- sequencer playback ----------
        let index = 0;
        let timer = -1;
        let playing = false;

        const SEQUENCER = document.getElementById("SEQUENCER");

        function clearActiveVisuals(){
          SEQUENCER.querySelectorAll(".row").forEach((rowEl)=>{
            rowEl.classList.remove("active");
            rowEl.querySelectorAll(".cellWrap").forEach((w)=>w.classList.remove("activeNote"));
          });
        }

        function renderActiveRow(r){
          const rowsEls = SEQUENCER.querySelectorAll(".row");
          rowsEls.forEach((rowEl, i)=>{
            rowEl.classList.toggle("active", i===r);
            rowEl.querySelectorAll(".cellWrap").forEach((w)=>w.classList.remove("activeNote"));
          });
        }

        async function playRow(r){
          renderActiveRow(r);
          stepMidiDispatch(r);

          const rowEl = SEQUENCER.children[r];
          if(!rowEl) return;

          const wraps = rowEl.querySelectorAll(".cellWrap");
          const dur = intervalMs(bpm)/1000;

          for(let c=0;c<COLS;c++){
            const isOn = !!gridOn[r][c];
            const cell = gridData[r][c];
            const hk = holdKeyForCol(c);

            if(isOn){
              wraps[c].classList.add("activeNote");
              if(cell.hold || glideEnabled){
                await startOrKeepHoldVoice(hk, cell);
              }else{
                if(activeVoices.has(hk)) stopHoldVoice(hk, cell);
                playOneShot(cell, dur);
              }
            } else {
              if(activeVoices.has(hk)){
                stopHoldVoice(hk, cell);
              }
            }
          }
        }

        function playNext(){
          const r = index;
          index = (index + 1) % ROWS;
          playRow(r);
        }

        function restartTimer(){
          if(timer !== -1) clearInterval(timer);
          timer = setInterval(()=> playNext(), intervalMs(bpm));
        }

        // ---------- transport ----------
        document.getElementById("play").addEventListener("click", async ()=>{
          if(audioCtx.state==="suspended") await audioCtx.resume();
          if(playing) return;
          playing = true;
          prevActiveNoteKeys = new Set();
          playNext();
          restartTimer();
        });

        document.getElementById("stop").addEventListener("click", ()=>{
          playing = false;
          if(timer !== -1) clearInterval(timer);
          timer = -1;
          clearActiveVisuals();

          for(const [k] of activeVoices.entries()){
            stopHoldVoice(k, { adsr: { r: 0.05 } });
          }
          activeVoices.clear();

          for(const key of prevActiveNoteKeys){
            const [chStr, noteStr] = key.split(":");
            midiNoteOff(Number(chStr), Number(noteStr), 0);
          }
          prevActiveNoteKeys = new Set();
          midiAllNotesOff();
        });

        // ---------- Dropdown UI refs ----------
        const DROPDOWN = document.getElementById("DROPDOWN");
        const ddSub = document.getElementById("ddSub");
        const ddClose = document.getElementById("ddClose");

        const uiHold = document.getElementById("uiHold");

        const uiFreq = document.getElementById("uiFreq");
        const uiFreqSlider = document.getElementById("uiFreqSlider");
        const uiWave = document.getElementById("uiWave");
        const uiSource = document.getElementById("uiSource");
        const uiLoadSample = document.getElementById("uiLoadSample");
        const uiSampleStart = document.getElementById("uiSampleStart");
        const uiSampleLen = document.getElementById("uiSampleLen");
        const hiddenSampleFile = document.getElementById("hiddenSampleFile");

        const uiA = document.getElementById("uiA");
        const uiD = document.getElementById("uiD");
        const uiS = document.getElementById("uiS");
        const uiR = document.getElementById("uiR");

        const uiFXType = document.getElementById("uiFXType");
        const uiFX1 = document.getElementById("uiFX1");
        const uiFX2 = document.getElementById("uiFX2");
        const uiFXDryHold = document.getElementById("uiFXDryHold");
        const uiFXWetHold = document.getElementById("uiFXWetHold");

        const uiMidiEnable = document.getElementById("uiMidiEnable");
        const uiMidiCh = document.getElementById("uiMidiCh");
        const uiMidiCmd = document.getElementById("uiMidiCmd");
        const uiMidiNote = document.getElementById("uiMidiNote");
        const uiMidiVel = document.getElementById("uiMidiVel");
        const uiMidiCCN = document.getElementById("uiMidiCCN");
        const uiMidiCCV = document.getElementById("uiMidiCCV");
        const uiMidiProg = document.getElementById("uiMidiProg");
        const uiMidiPB = document.getElementById("uiMidiPB");

        const rowMidiNote = document.getElementById("rowMidiNote");
        const rowMidiVel = document.getElementById("rowMidiVel");
        const rowMidiCCN = document.getElementById("rowMidiCCN");
        const rowMidiCCV = document.getElementById("rowMidiCCV");
        const rowMidiProg = document.getElementById("rowMidiProg");
        const rowMidiPB = document.getElementById("rowMidiPB");

        const uiPreviewHold = document.getElementById("uiPreviewHold");

        uiFXType.innerHTML = FX_TYPES.map(t=>`<option value="${t}">${t}</option>`).join("");

        let selected = { r:0, c:0 };
        let dropdownOpenFor = null;

        function closeDropdown(){
          DROPDOWN.style.display = "none";
          DROPDOWN.setAttribute("aria-hidden","true");
          dropdownOpenFor = null;
        }

        function updateMidiCmdUI(){
          const cmd = uiMidiCmd.value;
          rowMidiNote.style.display = (cmd==="note") ? "" : "none";
          rowMidiVel.style.display  = (cmd==="note") ? "" : "none";
          rowMidiCCN.style.display  = (cmd==="cc") ? "" : "none";
          rowMidiCCV.style.display  = (cmd==="cc") ? "" : "none";
          rowMidiProg.style.display = (cmd==="program") ? "" : "none";
          rowMidiPB.style.display   = (cmd==="pitchbend") ? "" : "none";
        }
        uiMidiCmd.addEventListener("change", () => { updateMidiCmdUI(); syncFromDropdown(); });

        function setFreqUI(v){
          v = clamp(Number(v)||1, 1, 10000);
          uiFreq.value = String(v);
          uiFreqSlider.value = String(Math.round(v));
        }

        function syncFromDropdown(){
          const cell = gridData[selected.r][selected.c];

          cell.hold = !!uiHold.checked;

          const f = clamp(Number(uiFreq.value)||1, 1, 10000);
          cell.freq = f;

          cell.wave = uiWave.value;
          cell.source = uiSource.value;
          // Sample slice (percent)
          if(!cell.sample) cell.sample = { url:"", name:"", startPct:0.00, lengthPct:100.00 };
          const sp = clamp(Number(uiSampleStart.value)||0, 0, 100);
          const lp = clamp(Number(uiSampleLen.value)||100, 0.01, 100);
          cell.sample.startPct = Number(sp.toFixed(2));
          cell.sample.lengthPct = Number(lp.toFixed(2));

          cell.adsr.a = Math.max(0, Number(uiA.value)||0);
          cell.adsr.d = Math.max(0, Number(uiD.value)||0);
          cell.adsr.s = clamp(Number(uiS.value)||0, 0, 10);
          cell.adsr.r = Math.max(0, Number(uiR.value)||0);

          cell.fx.type = uiFXType.value;
          cell.fx.p1 = Number(uiFX1.value)||0;
          cell.fx.p2 = Number(uiFX2.value)||0;

          cell.midi.enable = !!uiMidiEnable.checked;
          cell.midi.ch = clampInt(uiMidiCh.value, 1, 16);
          cell.midi.cmd = uiMidiCmd.value;

          cell.midi.note = clampInt(uiMidiNote.value, 0, 127);
          cell.midi.vel  = clampInt(uiMidiVel.value, 0, 127);
          cell.midi.ccN  = clampInt(uiMidiCCN.value, 0, 127);
          cell.midi.ccV  = clampInt(uiMidiCCV.value, 0, 127);
          cell.midi.program = clampInt(uiMidiProg.value, 0, 127);
          cell.midi.pitchbend = clampInt(uiMidiPB.value, -8192, 8191);

          scheduleSave();
        }

        uiFreq.addEventListener("input", ()=>{
          setFreqUI(uiFreq.value);
          syncFromDropdown();
        });
        uiFreqSlider.addEventListener("input", ()=>{
          setFreqUI(uiFreqSlider.value);
          syncFromDropdown();
        });

        [
          uiHold, uiWave, uiSource,
          uiA, uiD, uiS, uiR,
          uiFXType, uiFX1, uiFX2,
          uiMidiEnable, uiMidiCh, uiMidiCmd, uiMidiNote, uiMidiVel, uiMidiCCN, uiMidiCCV, uiMidiProg, uiMidiPB
        ].forEach(el=>{
          el.addEventListener("input", syncFromDropdown);
          el.addEventListener("change", syncFromDropdown);
        });

        function openDropdownForCell(cellWrapEl, r, c){
          if(dropdownOpenFor && dropdownOpenFor.r===r && dropdownOpenFor.c===c){
            closeDropdown(); return;
          }
          selected = { r, c };
          dropdownOpenFor = { r, c };

          const cell = gridData[r][c];
          ddSub.textContent = `Rij ${r+1}, Kolom ${c+1}`;

          uiHold.checked = !!cell.hold;

          setFreqUI(cell.freq);

          uiWave.value = cell.wave;
          uiSource.value = cell.source;

          uiA.value = cell.adsr.a;
          uiD.value = cell.adsr.d;
          uiS.value = cell.adsr.s;
          uiR.value = cell.adsr.r;

          uiFXType.value = cell.fx.type;
          uiFX1.value = cell.fx.p1;
          uiFX2.value = cell.fx.p2;

          uiMidiEnable.checked = !!cell.midi.enable;
          uiMidiCh.value = String(cell.midi.ch || 1);
          uiMidiCmd.value = cell.midi.cmd || "note";
          uiMidiNote.value = String(cell.midi.note ?? 60);
          uiMidiVel.value = String(cell.midi.vel ?? 100);
          uiMidiCCN.value = String(cell.midi.ccN ?? 1);
          uiMidiCCV.value = String(cell.midi.ccV ?? 0);
          uiMidiProg.value = String(cell.midi.program ?? 0);
          uiMidiPB.value = String(cell.midi.pitchbend ?? 0);

          updateMidiCmdUI();

          DROPDOWN.style.display = "block";
          DROPDOWN.setAttribute("aria-hidden","false");

          const rect = cellWrapEl.getBoundingClientRect();
          const pad = 8, gap = 6;

          let x = rect.left;
          let y = rect.bottom + gap;

          const ddRect = DROPDOWN.getBoundingClientRect();
          if(y + ddRect.height > window.innerHeight - pad) y = rect.top - gap - ddRect.height;
          if(x + ddRect.width > window.innerWidth - pad) x = window.innerWidth - pad - ddRect.width;
          if(x < pad) x = pad;
          if(y < pad) y = pad;

          DROPDOWN.style.left = `${x}px`;
          DROPDOWN.style.top = `${y}px`;
        }

        ddClose.addEventListener("click", closeDropdown);
        window.addEventListener("keydown", (e)=>{ if(e.key==="Escape") closeDropdown(); });

        // ---------- sample loader in dropdown ----------
        uiLoadSample.addEventListener("click", ()=>{
          hiddenSampleFile.click();
        });

        hiddenSampleFile.addEventListener("change", async ()=>{
          const file = hiddenSampleFile.files && hiddenSampleFile.files[0];
          hiddenSampleFile.value = "";
          if(!file) return;
          try{
            const url = URL.createObjectURL(file);
            await loadSampleToCache(url, file);
            const cell = gridData[selected.r][selected.c];
            cell.sample.url = url;
            cell.sample.name = file.name || "sample";
            cell.source = "sample";
            uiSource.value = "sample";
            scheduleSave(true);
            setStatus("sample loaded");
          }catch(e){
            showError(e);
            setStatus("sample failed");
          }
        });

        // ---------- preview (hold) ----------
        function snapshotForHold(cell){
          return {
            source: cell.source,
            sampleUrl: cell.sample?.url || "",
            freq: cell.freq, wave: cell.wave,
            hold: cell.hold,
            adsr: { a:cell.adsr.a, d:cell.adsr.d, s:cell.adsr.s, r:cell.adsr.r },
            fxType: cell.fx?.type || "none",
            fx1: cell.fx?.p1 || 0,
            fx2: cell.fx?.p2 || 0
          };
        }

        async function playHoldVoiceLooping(cell, mode="wet"){
          if(audioCtx.state==="suspended") await audioCtx.resume();
          const now = audioCtx.currentTime;

          const gain = audioCtx.createGain();
          gain.gain.setValueAtTime(EPS, now);

          // DRY bypass FX
          let fxChain;
          if(mode === "dry"){
            fxChain = { out: gain, cleanup: ()=>{} };
          }else{
            fxChain = createFXChain(audioCtx, cell.fx, gain);
          }
          fxChain.out.connect(masterGain);

          if(cell.source === "sample" && cell.sample && cell.sample.url){
            const buf = sampleCache.get(cell.sample.url);
            if(!buf) throw new Error("Sample not loaded for preview");

            const src = audioCtx.createBufferSource();
            src.buffer = buf;
            src.loop = true;
            src.connect(gain);

            const A = Math.max(EPS, getEffectiveADSR(cell).a);
            const D = Math.max(EPS, getEffectiveADSR(cell).d);
            const S = clamp(getEffectiveADSR(cell).s, 0, 10);

            const peak = 0.6;
            const sustainLevel = Math.max(0, Math.min(1, peak * (S / 10)));

            gain.gain.cancelScheduledValues(now);
            gain.gain.setValueAtTime(EPS, now);
            gain.gain.linearRampToValueAtTime(Math.max(EPS, peak), now + A);
            gain.gain.linearRampToValueAtTime(Math.max(EPS, sustainLevel), now + A + D);
            gain.gain.setValueAtTime(Math.max(EPS, sustainLevel), now + A + D + 0.0001);

            src.start(now);

            return { src, gain, fxChain, cellSnapshot: { ...snapshotForHold(cell), previewMode: mode } };
          }

          const osc = audioCtx.createOscillator();
          osc.type = cell.wave;
          osc.frequency.setValueAtTime(Math.max(1, Number(cell.freq)||440), now);
          osc.connect(gain);

          const A = Math.max(EPS, getEffectiveADSR(cell).a);
          const D = Math.max(EPS, getEffectiveADSR(cell).d);
          const S = clamp(getEffectiveADSR(cell).s, 0, 10);

          const peak = 0.22;
          const sustainLevel = Math.max(0, Math.min(1, peak * (S / 10)));

          gain.gain.cancelScheduledValues(now);
          gain.gain.setValueAtTime(EPS, now);
          gain.gain.linearRampToValueAtTime(Math.max(EPS, peak), now + A);
          gain.gain.linearRampToValueAtTime(Math.max(EPS, sustainLevel), now + A + D);
          gain.gain.setValueAtTime(Math.max(EPS, sustainLevel), now + A + D + 0.0001);

          osc.start(now);

          return { osc, gain, fxChain, cellSnapshot: { ...snapshotForHold(cell), previewMode: mode } };
        }

        function stopHoldPreview(){
          isHolding = false;
          if(!holdVoice) return;
          const now = audioCtx.currentTime;
          const cell = gridData[selected.r][selected.c];
          const R = Math.max(EPS, getEffectiveADSR(cell).r);
          const Rf = Math.max(R, CLICK_FADE);

          try{
            holdVoice.gain.gain.cancelScheduledValues(now);
            const cur = Math.max(EPS, holdVoice.gain.gain.value || EPS);
            holdVoice.gain.gain.setValueAtTime(cur, now);
            // anti-click: ensure we don't jump
            
            holdVoice.gain.gain.linearRampToValueAtTime(0, now + Math.max(R, CLICK_FADE));
          }catch{}

          try{ if(holdVoice.osc) holdVoice.osc.stop(now + R + 0.02); }catch{}
          try{ if(holdVoice.src) holdVoice.src.stop(now + R + 0.02); }catch{}

          const node = holdVoice.osc || holdVoice.src;
          if(node){
            node.onended = () => {
              try{ node.disconnect(); }catch{}
              try{ holdVoice.fxChain.cleanup && holdVoice.fxChain.cleanup(); }catch{}
              try{ holdVoice.gain.disconnect(); }catch{}
            };
          }
          holdVoice = null;
        }

        async function startHoldPreview(){
          if(isHolding) return;
          isHolding = true;
          const cell = gridData[selected.r][selected.c];
          holdVoice = await playHoldVoiceLooping(cell, previewMode);
        }

        function updateHoldVoiceLive(){
          if(!holdVoice || holdRestarting) return;
          const cell = gridData[selected.r][selected.c];
          const snap = holdVoice.cellSnapshot;
          const needsRestart =
            (snap.source !== cell.source) ||
            (snap.sampleUrl !== (cell.sample?.url||"")) ||
            (snap.wave !== cell.wave) ||
            (snap.previewMode !== previewMode) ||
            (Math.abs(snap.freq - cell.freq) > 0.001) ||
            (Math.abs(snap.adsr.a - cell.adsr.a) > 0.0001) ||
            (Math.abs(snap.adsr.d - cell.adsr.d) > 0.0001) ||
            (Math.abs(snap.adsr.s - cell.adsr.s) > 0.0001) ||
            (Math.abs(snap.adsr.r - cell.adsr.r) > 0.0001) ||
            (snap.fxType !== (cell.fx?.type || "none")) ||
            (Math.abs(snap.fx1 - (cell.fx?.p1||0)) > 0.0001) ||
            (Math.abs(snap.fx2 - (cell.fx?.p2||0)) > 0.0001);

          if(needsRestart){
            holdRestarting = true;
            stopHoldPreview();
            setTimeout(async ()=>{
              if(isHolding){
                await startHoldPreview();
              }
              holdRestarting = false;
            }, 0);
          } else {
            // live parameter tweaks (freq)
            if(holdVoice.osc){
              try{ holdVoice.osc.frequency.setValueAtTime(Math.max(1, cell.freq), audioCtx.currentTime); }catch{}
            }
          }
        }

        // Bind main preview hold button
        uiPreviewHold.addEventListener("pointerdown", async (e)=>{
          e.preventDefault();
          uiPreviewHold.setPointerCapture(e.pointerId);
          previewMode = "wet";
          await startHoldPreview();
        });
        uiPreviewHold.addEventListener("pointerup", (e)=>{ e.preventDefault(); stopHoldPreview(); });
        uiPreviewHold.addEventListener("pointercancel", stopHoldPreview);

        function bindHoldButton(btn, mode){
          btn.addEventListener("pointerdown", async (e)=>{
            e.preventDefault();
            btn.setPointerCapture(e.pointerId);
            previewMode = mode;
            await startHoldPreview();
          });
          btn.addEventListener("pointerup", (e)=>{ e.preventDefault(); stopHoldPreview(); });
          btn.addEventListener("pointercancel", stopHoldPreview);
        }
        bindHoldButton(uiFXDryHold, "dry");
        bindHoldButton(uiFXWetHold, "wet");

        // update hold voice when you change params in dropdown
        const holdLiveInputs = [
          uiHold, uiFreq, uiFreqSlider, uiWave, uiSource,
          uiA, uiD, uiS, uiR,
          uiFXType, uiFX1, uiFX2
        ];
        holdLiveInputs.forEach(el=>{
          el.addEventListener("input", ()=>{ syncFromDropdown(); updateHoldVoiceLive(); });
          el.addEventListener("change", ()=>{ syncFromDropdown(); updateHoldVoiceLive(); });
        });

        // Stop preview on ESC
        window.addEventListener("keydown", (e)=>{
          if(e.key === "Escape"){
            stopHoldPreview();
            closeDropdown();
          }
        });

        // ---------- build grid ----------
        function buildGrid(){
          SEQUENCER.innerHTML = "";
          for(let r=0;r<ROWS;r++){
            const row = document.createElement("div");
            row.className = "row";
            row.dataset.row = String(r);

            const idxEl = document.createElement("div");
            idxEl.className = "stepIndex";
            idxEl.textContent = String(r+1).padStart(3,"0");
            idxEl.title = "Klik: preview / jump";
            idxEl.addEventListener("click", async ()=>{
              if(audioCtx.state==="suspended") await audioCtx.resume();
              if(playing){
                index = r;
                playNext();
                restartTimer();
              } else {
                prevActiveNoteKeys = new Set();
                await playRow(r);
                setTimeout(() => {
                  for(const key of prevActiveNoteKeys){
                    const [chStr, noteStr] = key.split(":");
                    midiNoteOff(Number(chStr), Number(noteStr), 0);
                  }
                  prevActiveNoteKeys = new Set();
                }, Math.max(30, intervalMs(bpm) - 5));
              }
            });
            row.appendChild(idxEl);

            for(let c=0;c<COLS;c++){
              const wrap = document.createElement("div");
              wrap.className = "cellWrap";
              if(gridOn[r][c]) wrap.classList.add("selected");

              const main = document.createElement("button");
              main.className = "cellMain";
              main.type = "button";
              main.addEventListener("click",(e)=>{
                e.stopPropagation();
                gridOn[r][c] = !gridOn[r][c];
                wrap.classList.toggle("selected", gridOn[r][c]);
                scheduleSave();
              });

              const handle = document.createElement("button");
              handle.className = "cellHandle";
              handle.type = "button";
              handle.textContent = "▾";
              handle.title = "menu";
              handle.addEventListener("click",(e)=>{
                e.stopPropagation();
                openDropdownForCell(wrap, r, c);
              });

              wrap.appendChild(main);
              wrap.appendChild(handle);
              row.appendChild(wrap);
            }

            SEQUENCER.appendChild(row);
          }
        }
// ---------- autosave state ----------
        function toState(){
          return {
            adsrEnabled: !!ADSR_ENABLED,
            adsrScale: Number(ADSR_SCALE) || 1,
            version: 7,
            bpm,
            index,
            rows: ROWS,
            cols: COLS,
            notesPerLine: COLS,
            midi: {
              sendMode: midiSendMode.value,
              overrideCh: clampInt(midiOverrideCh.value, 1, 16),
              outId: midiOutSelect.value || ""
            },
            fileName: fileNameEl.value || "sequencer-state",
            gridOn,
            gridData
          };
        }

        let saveT = -1;
        function scheduleSave(immediate=false){
          if(saveT !== -1) clearTimeout(saveT);
          saveT = setTimeout(()=>{
            try{
              localStorage.setItem(STORAGE_KEY, JSON.stringify(toState()));
            }catch{}
          }, immediate ? 0 : 250);
        }

// ---------- autosave helpers ----------
let autosaveTimer = null;

function forceAutosaveNow(){
  // Use the existing save pipeline (safer than touching state internals).
  try{ scheduleSave(true); }catch{}
  // Also attempt a direct write if available (extra safety, but guarded).
  try{
    if(typeof toState === "function"){
      localStorage.setItem(STORAGE_KEY, JSON.stringify(toState()));
    }
  }catch{}
}

function startAutosaveTimer(){
  if(autosaveTimer) return;
  autosaveTimer = setInterval(()=>{
    forceAutosaveNow();
  }, AUTOSAVE_EVERY_MS);
}

function stopAutosaveTimer(){
  if(!autosaveTimer) return;
  clearInterval(autosaveTimer);
  autosaveTimer = null;
}


        function loadState(state){
          if(!state || typeof state !== "object") throw new Error("Invalid state");
          if(!Array.isArray(state.gridOn) || !Array.isArray(state.gridData)) throw new Error("Missing gridOn/gridData");

          const rows = Number(state.rows) || state.gridOn.length;
          const cols = Number(state.cols) || (state.gridOn[0] ? state.gridOn[0].length : COLS);

          // Resize and load
          initGrid(rows, cols);

          for(let r=0;r<ROWS;r++){
            for(let c=0;c<COLS;c++){
              gridOn[r][c] = !!state.gridOn?.[r]?.[c];

              const src = state.gridData?.[r]?.[c] || {};
              const dst = gridData[r][c];

              dst.hold = !!(src.hold ?? dst.hold);
              dst.freq = clamp(Number(src.freq ?? dst.freq), 1, 10000);
              dst.wave = String(src.wave ?? dst.wave);
              dst.source = String(src.source ?? dst.source);

              dst.sample = dst.sample || { url:"", name:"", startPct:0.00, lengthPct:100.00 };
              dst.sample.url = String(src.sample?.url ?? dst.sample.url ?? "");
              dst.sample.name = String(src.sample?.name ?? dst.sample.name ?? "");
              dst.sample.startPct = clamp(Number(src.sample?.startPct ?? dst.sample.startPct ?? 0), 0, 100);
              dst.sample.lengthPct = clamp(Number(src.sample?.lengthPct ?? dst.sample.lengthPct ?? 100), 0.01, 100);

              dst.adsr.a = Number(src.adsr?.a ?? dst.adsr.a);
              dst.adsr.d = Number(src.adsr?.d ?? dst.adsr.d);
              dst.adsr.s = Number(src.adsr?.s ?? dst.adsr.s);
              dst.adsr.r = Number(src.adsr?.r ?? dst.adsr.r);

              dst.fx.type = String(src.fx?.type ?? dst.fx.type);
              dst.fx.p1 = Number(src.fx?.p1 ?? dst.fx.p1);
              dst.fx.p2 = Number(src.fx?.p2 ?? dst.fx.p2);

              dst.midi.enable = !!(src.midi?.enable ?? dst.midi.enable);
              dst.midi.ch = clampInt(src.midi?.ch ?? dst.midi.ch, 1, 16);
              dst.midi.cmd = String(src.midi?.cmd ?? dst.midi.cmd);
              dst.midi.note = clampInt(src.midi?.note ?? dst.midi.note, 0, 127);
              dst.midi.vel  = clampInt(src.midi?.vel  ?? dst.midi.vel,  0, 127);
              dst.midi.ccN  = clampInt(src.midi?.ccN  ?? dst.midi.ccN,  0, 127);
              dst.midi.ccV  = clampInt(src.midi?.ccV  ?? dst.midi.ccV,  0, 127);
              dst.midi.program = clampInt(src.midi?.program ?? dst.midi.program, 0, 127);
              dst.midi.pitchbend = clampInt(src.midi?.pitchbend ?? dst.midi.pitchbend, -8192, 8191);
            }
          }

          if(typeof state.bpm === "number") setBpm(state.bpm);
          if(state.fileName) fileNameEl.value = String(state.fileName);

          // notes per line
          if(state.notesPerLine) {
            notesPerLineEl.value = String(state.notesPerLine);
            COLS = clampInt(state.notesPerLine, 4, 64);
          }

          if(state.midi && typeof state.midi === "object"){
            if(state.midi.sendMode) midiSendMode.value = state.midi.sendMode;
            if(state.midi.overrideCh) midiOverrideCh.value = String(clampInt(state.midi.overrideCh,1,16));
            updateOverrideVisibility();

            const outId = state.midi.outId || "";
            if(outId){
              if(midiAccess && midiAccess.outputs && midiAccess.outputs.get(outId)){
                midiOutSelect.value = outId;
                midiOut = midiAccess.outputs.get(outId);
              } else {
                restoreMidiOutByIdWithRetry(outId);
              }
            }
          }

          closeDropdown();
          buildGrid();
          scheduleSave(true);
          setStatus("loaded");
        }

        // ---------- Load autosave on startup ----------
        try{
          const raw = localStorage.getItem(STORAGE_KEY);
          if(raw){
            loadState(JSON.parse(raw));
          } else {
            buildGrid();
            scheduleSave(true);
          }
        }catch(e){
          console.warn("autosave load failed", e);
          buildGrid();
          scheduleSave(true);
        }

        // ---------- JSON Download/Upload ----------
        const jsonFileInput = document.getElementById("jsonFileInput");

        document.getElementById("saveJson").addEventListener("click", ()=>{
          try{
            const base = (getLoadedMidiBaseName() || sanitizeFileName(fileNameEl.value));
            const filename = base.endsWith(".json") ? base : base + ".json";
            const blob = new Blob([JSON.stringify(toState(), null, 2)], { type:"application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);

            // If using GK naming, bump daily counter for the next export
            try{
              const baseName = sanitizeFileName(fileNameEl.value);
              const ymd = todayYMD();
              if(/^GK\d{11}$/.test(baseName) && baseName.startsWith("GK"+ymd)){
                bumpGKCounter();
                const nextName = getCurrentGKName();
                fileNameEl.value = nextName;
                localStorage.setItem(STORAGE_KEY_FILENAME, nextName);
              }
            }catch{}

            setStatus("downloaded");
          }catch(e){ showError(e); }
        });

        document.getElementById("loadJson").addEventListener("click", ()=> jsonFileInput.click());
        jsonFileInput.addEventListener("change", async ()=>{
          const file = jsonFileInput.files && jsonFileInput.files[0];
          jsonFileInput.value = "";
          if(!file) return;
          try{
            const text = await file.text();
            const state = JSON.parse(text);
            loadState(state);

            const name = (file.name || "").replace(/\.json$/i, "");
            if(name){
              fileNameEl.value = sanitizeFileName(name);
              try{ localStorage.setItem(STORAGE_KEY_FILENAME, fileNameEl.value); }catch{}
            }
            setStatus("loaded file");
          }catch(e){ showError(e); }
        });

        // ---------- Reset ----------
        document.getElementById("resetAll").addEventListener("click", ()=>{
          playing = false;
          if(timer !== -1) clearInterval(timer);
          timer = -1;
          clearActiveVisuals();

          midiAllNotesOff();
          prevActiveNoteKeys = new Set();

          for(const [k] of activeVoices.entries()){
            stopHoldVoice(k, { adsr: { r: 0.05 } });
          }
          activeVoices.clear();

          setBpm(120.0);
          initGrid(128, Number(notesPerLineEl.value)||13);
          closeDropdown();
          buildGrid();
          stopAutosaveTimer();
          try{ localStorage.removeItem(STORAGE_KEY); }catch{}
          scheduleSave(true);
          startAutosaveTimer();
          setStatus("reset");
        });

        // ============================================================
        // ===================== MIDI IMPORT (resize) ==================
        // ============================================================
        function u8str(u8, off, len){ let s=""; for(let i=0;i<len;i++) s += String.fromCharCode(u8[off+i]||0); return s; }
        function be16(u8, off){ return (u8[off]<<8) | (u8[off+1]); }
        function be32(u8, off){ return (u8[off]<<24) | (u8[off+1]<<16) | (u8[off+2]<<8) | (u8[off+3]); }

        function readVLQ(u8, off){
          let v=0, i=0;
          while(true){
            if(off+i >= u8.length) throw new Error("VLQ out of range");
            const b = u8[off+i];
            v = (v<<7) | (b & 0x7F);
            i++;
            if((b & 0x80) === 0) break;
            if(i > 4) throw new Error("VLQ too long");
          }
          return { value:v, bytes:i };
        }

        function parseMIDI(buf){
          const u8 = new Uint8Array(buf);
          let off=0;

          if(u8str(u8, off, 4) !== "MThd") throw new Error("Not MIDI: missing MThd");
          const headerLen = be32(u8, off+4);
          if(headerLen < 6) throw new Error("Bad MThd length");
          const nTracks = be16(u8, off+10);
          const division = be16(u8, off+12);
          off += 8 + headerLen;

          const ppq = (division & 0x8000) ? null : division;
          if(!ppq) throw new Error("SMPTE timing not supported");

          const tracks = [];
          for(let t=0;t<nTracks;t++){
            if(off + 8 > u8.length) throw new Error("Unexpected EOF (track header)");
            if(u8str(u8, off, 4) !== "MTrk") throw new Error("Missing MTrk at track " + t);
            const len = be32(u8, off+4);
            off += 8;
            const end = off + len;
            if(end > u8.length) throw new Error("Track length out of range");

            let tick=0, runningStatus=0;
            const events=[];

            while(off < end){
              const d = readVLQ(u8, off);
              tick += d.value;
              off += d.bytes;
              if(off >= end) break;

              let status = u8[off];
              if(status < 0x80){
                if(!runningStatus) throw new Error("Running status without previous status");
                status = runningStatus;
              }else{
                off++;
                runningStatus = status;
              }

              if(status === 0xFF){
                if(off >= end) throw new Error("Meta event truncated");
                const type = u8[off]; off++;
                const l = readVLQ(u8, off); off += l.bytes;
                const dataEnd = off + l.value;
                if(dataEnd > end) throw new Error("Meta length out of range");
                const data = u8.slice(off, dataEnd);
                off = dataEnd;
                events.push({ tick, kind:"meta", type, data });
                continue;
              }

              if(status === 0xF0 || status === 0xF7){
                const l = readVLQ(u8, off); off += l.bytes + l.value;
                if(off > end) throw new Error("SysEx out of range");
                continue;
              }

              const cmd = status & 0xF0;
              const ch = status & 0x0F;

              if(cmd === 0xC0 || cmd === 0xD0){
                if(off >= end) throw new Error("MIDI event truncated (1 byte)");
                const d1 = u8[off]; off++;
                events.push({ tick, kind:"midi", cmd, ch, d1, d2:null });
              }else{
                if(off + 1 >= end) throw new Error("MIDI event truncated (2 bytes)");
                const d1 = u8[off], d2 = u8[off+1];
                off += 2;
                events.push({ tick, kind:"midi", cmd, ch, d1, d2 });
              }
            }

            tracks.push(events);
            off = end;
          }

          return { ppq, tracks };
        }

        function extractTempoMap(midi){
          const map=[];
          for(const tr of midi.tracks){
            for(const e of tr){
              if(e.kind==="meta" && e.type===0x51 && e.data && e.data.length===3){
                const us = (e.data[0]<<16) | (e.data[1]<<8) | e.data[2];
                map.push({ tick:e.tick, usPerQN:us });
              }
            }
          }
          map.sort((a,b)=>a.tick-b.tick);
          if(!map.length) map.push({ tick:0, usPerQN:500000 });
          if(map[0].tick !== 0) map.unshift({ tick:0, usPerQN:500000 });
          return map;
        }
        function getFirstTempoBPM(map){
          const us = map && map.length ? map[0].usPerQN : 500000;
          return 60e6 / us;
        }
        function ticksToSeconds(tick, tempoMap, ppq){
          let sec=0;
          for(let i=0;i<tempoMap.length;i++){
            const cur = tempoMap[i];
            const next = tempoMap[i+1];
            const nextTick = next ? next.tick : tick;
            const span = Math.min(tick, nextTick) - cur.tick;
            if(span > 0) sec += (span / ppq) * (cur.usPerQN / 1e6);
            if(next && tick >= next.tick) continue;
            break;
          }
          return sec;
        }

        function extractNoteRanges(midi){
          const ranges=[];
          const active=new Map(); // key `${ch}:${note}` -> {startTick, vel}
          for(const tr of midi.tracks){
            for(const e of tr){
              if(e.kind !== "midi") continue;
              const cmd=e.cmd, ch=e.ch, note=e.d1;

              const isOn  = (cmd===0x90 && e.d2>0);
              const isOff = (cmd===0x80) || (cmd===0x90 && e.d2===0);

              if(isOn){
                const key=`${ch}:${note}`;
                if(active.has(key)){
                  const prev=active.get(key);
                  ranges.push({ startTick:prev.startTick, endTick:e.tick, note, ch, vel:prev.vel });
                }
                active.set(key, { startTick:e.tick, vel:e.d2 });
              }
              if(isOff){
                const key=`${ch}:${note}`;
                if(active.has(key)){
                  const prev=active.get(key);
                  ranges.push({ startTick:prev.startTick, endTick:e.tick, note, ch, vel:prev.vel });
                  active.delete(key);
                }
              }
            }
          }
          let maxTick=0;
          for(const tr of midi.tracks) for(const e of tr) maxTick = Math.max(maxTick, e.tick||0);
          for(const [key, prev] of active.entries()){
            const [chStr, noteStr] = key.split(":");
            ranges.push({ startTick:prev.startTick, endTick:maxTick, note:Number(noteStr), ch:Number(chStr), vel:prev.vel });
          }
          return ranges.map(r=>({ ...r, endTick: Math.max(r.endTick, r.startTick) }));
        }

        function midiImportToGrid(midi){
          const tempoMap = extractTempoMap(midi);
          const fileBpm = getFirstTempoBPM(tempoMap);
          if(Number.isFinite(fileBpm) && fileBpm>1 && fileBpm<400) setBpm(fileBpm);

          const ranges = extractNoteRanges(midi);
          if(!ranges.length){ setStatus("MIDI: geen noten"); return; }

          // Determine required length in steps (resize)
          const stepDurSec = intervalMs(bpm)/1000;
          let maxEndSec = 0;
          for(const n of ranges){
            const endSec = ticksToSeconds(n.endTick, tempoMap, midi.ppq);
            maxEndSec = Math.max(maxEndSec, endSec);
          }
          const neededSteps = Math.max(1, Math.ceil(maxEndSec / stepDurSec) + 1);

          // Resize rows if needed (preserve cols)
          if(neededSteps !== ROWS){
            const oldOn = gridOn;
            const oldData = gridData;
            const oldRows = ROWS;
            const cols = COLS;

            initGrid(neededSteps, cols);

            // we are importing; clear everything first
          }

          for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) gridOn[r][c] = false;

          const uniq = Array.from(new Set(ranges.map(n=>n.note))).sort((a,b)=>b-a);
          const pitchToCol = new Map();
          for(let i=0;i<Math.min(COLS, uniq.length);i++) pitchToCol.set(uniq[i], i);
          const colForPitch = (p)=> pitchToCol.has(p) ? pitchToCol.get(p) : (p % COLS);

          for(const n of ranges){
            const startSec = ticksToSeconds(n.startTick, tempoMap, midi.ppq);
            const endSec   = ticksToSeconds(n.endTick, tempoMap, midi.ppq);

            let startStep = Math.floor(startSec / stepDurSec);
            let endStepEx = Math.ceil(endSec / stepDurSec);
            if(endStepEx <= startStep) endStepEx = startStep + 1;

            startStep = Math.max(0, Math.min(ROWS-1, startStep));
            endStepEx = Math.max(0, Math.min(ROWS, endStepEx));

            const c = colForPitch(n.note);
            const hz = Number(midiNoteToHz(n.note).toFixed(2));

            for(let step=startStep; step<endStepEx; step++){
              gridOn[step][c] = true;
              const cell = gridData[step][c];
              cell.freq = hz;
              cell.wave = "sine";
              cell.source = "osc";
              cell.hold = true; // hold across note length
              cell.midi.enable = false;
              cell.midi.cmd = "note";
              cell.midi.ch = (n.ch + 1);
              cell.midi.note = n.note;
              cell.midi.vel = clampInt(n.vel,0,127);
            }
          }

          closeDropdown();
          buildGrid();
          scheduleSave(true);
          setStatus("MIDI geïmporteerd");
        }

        const midiLoadBtn = document.getElementById("midiLoadBtn");
        const midiFileInput = document.getElementById("midiFileInput");

        // Remember last loaded MIDI filename (for video export naming)
        window._lastLoadedMidiFileName = "";
        const midiSampleBtn = document.getElementById("midiSampleBtn");
        const midiSampleAudioInput = document.getElementById("midiSampleAudioInput");
        const midiSampleMidiInput = document.getElementById("midiSampleMidiInput");
        const midiSampleRoot = document.getElementById("midiSampleRoot");

        midiLoadBtn.addEventListener("click", ()=>{
          ERROR.style.display = "none";
          ERROR.textContent = "";
          midiFileInput.click();
        });

        midiFileInput.addEventListener("change", async ()=>{
          const file = midiFileInput.files && midiFileInput.files[0];
          midiFileInput.value = "";
          if(!file) return;

          // store filename for exports
          try{ window._lastLoadedMidiFileName = file.name || ""; }catch{}

          // also set base name textbox for convenience
          try{
            const base = getLoadedMidiBaseName();
            if(base && typeof fileNameEl !== "undefined" && fileNameEl) fileNameEl.value = base;
          }catch{}
          try{
  
        // ---------- Sample → MIDI (audio slices pitched by MIDI notes) ----------
        
// ---------- Sample → MIDI (two buttons) ----------
// Load Sample: pick audio, remember it
// Apply sample to loaded MIDI: pick midi, slice+pitch the loaded audio by MIDI notes
const s2mLoadSampleBtn = document.getElementById("s2mLoadSampleBtn");
const s2mLoadMidiBtn   = document.getElementById("s2mLoadMidiBtn");

// Remember last loaded MIDI for applying a loaded sample without re-picking a file
window._lastLoadedMidiForS2M = null;


let _midiSamplePendingAudioFile = null;
        let _s2mPickerBusy = false;
function s2mUpdateButtons(){
  const hasSample = !!_midiSamplePendingAudioFile;
  const hasMidi = !!window._lastLoadedMidiForS2M;
  if(s2mLoadMidiBtn) s2mLoadMidiBtn.disabled = !(hasSample && hasMidi);
  if(s2mLoadSampleBtn){
    s2mLoadSampleBtn.textContent = hasSample
      ? ("Sample: " + (_midiSamplePendingAudioFile.name || "loaded"))
      : "Load Sample";
  }
}

if(midiSampleAudioInput){
  midiSampleAudioInput.addEventListener("change", ()=>{
          try{

    const f = midiSampleAudioInput.files && midiSampleAudioInput.files[0];
    midiSampleAudioInput.value = "";
    if(!f) return;
    _midiSamplePendingAudioFile = f;
    s2mUpdateButtons();
    setStatus("sample loaded");
          } finally {
            _s2mPickerBusy = false;
            setTimeout(()=>{ _s2mPickerBusy = false; }, 250);
          }
        });
}

if(midiSampleMidiInput){
  midiSampleMidiInput.addEventListener("change", async ()=>{
          try{

    const midiFile = midiSampleMidiInput.files && midiSampleMidiInput.files[0];
    midiSampleMidiInput.value = "";
    if(!midiFile) return;

    if(!_midiSamplePendingAudioFile){
      setStatus("load sample first");
      return;
    }

    try{
      if(audioCtx.state==="suspended") await audioCtx.resume();

      ERROR.style.display = "none";
      ERROR.textContent = "";

      const audioFile = _midiSamplePendingAudioFile;

      // Decode audio
      const audioBufArr = await audioFile.arrayBuffer();
      const audioBuffer = await audioCtx.decodeAudioData(audioBufArr.slice(0));

      // Parse MIDI
      const midiArr = await midiFile.arrayBuffer();
      const midi = parseMIDI(midiArr);

      let rootNote = 60; try{ if(midiSampleRoot) rootNote = clampInt(Number(midiSampleRoot.value),0,127); }catch{}
      midiApplySampleToGrid(midi, audioBuffer, audioFile.name || "sample", rootNote);

      _s2mPickerBusy = false; setTimeout(()=>{ _s2mPickerBusy = false; }, 250);
            setStatus("sample applied to midi");
    }catch(e){
      showError(e);
    }
          } finally {
            _s2mPickerBusy = false;
            setTimeout(()=>{ _s2mPickerBusy = false; }, 250);
          }
        });
}

if(s2mLoadSampleBtn && midiSampleAudioInput){
  s2mLoadSampleBtn.addEventListener("click", ()=>{
  // Guard against double-trigger on some Android/content viewers
  if(_s2mPickerBusy) return;
  _s2mPickerBusy = true;

  try{ audioCtx.resume(); }catch{}
  setStatus("pick sample…");
  try{ ERROR.style.display = "none"; ERROR.textContent = ""; }catch{}
  try{ midiSampleAudioInput.value = ""; }catch{}
  try{ midiSampleAudioInput.click(); }catch(e){ _s2mPickerBusy = false; throw e; }
});
}

if(s2mLoadMidiBtn && midiSampleMidiInput){
  s2mLoadMidiBtn.addEventListener("click", async ()=>{
    if(_s2mPickerBusy) return;
    _s2mPickerBusy = true;

    try{
      try{ audioCtx.resume(); }catch{}

      if(!_midiSamplePendingAudioFile){
        setStatus("load sample first");
        _s2mPickerBusy = false;
        return;
      }

      // If we already have a loaded MIDI, apply immediately (no picker)
      if(window._lastLoadedMidiForS2M){
        setStatus("applying sample to loaded MIDI…");
        try{ ERROR.style.display = "none"; ERROR.textContent = ""; }catch{}

        if(audioCtx.state==="suspended") await audioCtx.resume();

        const audioFile = _midiSamplePendingAudioFile;
        const audioBufArr = await audioFile.arrayBuffer();
        const audioBuffer = await audioCtx.decodeAudioData(audioBufArr.slice(0));

        let rootNote = 60; try{ if(midiSampleRoot) rootNote = clampInt(Number(midiSampleRoot.value),0,127); }catch{}
        midiApplySampleToGrid(window._lastLoadedMidiForS2M, audioBuffer, audioFile.name || "sample", rootNote);

        setStatus("sample applied to loaded MIDI");
        _s2mPickerBusy = false;
        return;
      }

      // Fallback: pick MIDI file (old behavior)
      setStatus("pick midi…");
      try{ ERROR.style.display = "none"; ERROR.textContent = ""; }catch{}
      try{ midiSampleMidiInput.value = ""; }catch{}
      try{ midiSampleMidiInput.click(); }catch(e){ _s2mPickerBusy = false; throw e; }
    }catch(e){
      showError(e);
      setStatus("apply failed");
      _s2mPickerBusy = false;
    }
  });
}


s2mUpdateButtons();



        function midiApplySampleToGrid(midi, audioBuffer, audioName, rootNote=60){
          if(!midi || !audioBuffer) return;

          const tempoMap = extractTempoMap(midi);
          const fileBpm = getFirstTempoBPM(tempoMap);
          if(Number.isFinite(fileBpm) && fileBpm>1 && fileBpm<400) setBpm(fileBpm);

          const ranges = extractNoteRanges(midi);
          if(!ranges.length){ setStatus("MIDI: geen noten"); return; }

          // Total MIDI duration (seconds)
          let maxEndSec = 0;
          for(const n of ranges){
            const endSec = ticksToSeconds(n.endTick, tempoMap, midi.ppq);
            if(endSec > maxEndSec) maxEndSec = endSec;
          }
          maxEndSec = Math.max(0.001, maxEndSec);

          // Resize to fit MIDI (same logic as import)
          const stepDurSec = intervalMs(bpm)/1000;
          const neededSteps = Math.max(1, Math.ceil(maxEndSec / stepDurSec) + 1);
          if(neededSteps !== ROWS){
            initGrid(neededSteps, COLS);
          }

          // Clear grid
          for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) gridOn[r][c] = false;

          // Cache audio under a synthetic key (so cells can reference it)
          const sampleKey = "__midisample__" + Date.now() + "__" + Math.floor(Math.random()*1e9);
          try{ sampleCache.set(sampleKey, audioBuffer); }catch{}

          // Map pitches to columns (highest notes left)
          const uniq = Array.from(new Set(ranges.map(n=>n.note))).sort((a,b)=>b-a);
          const pitchToCol = new Map();
          for(let i=0;i<Math.min(COLS, uniq.length);i++) pitchToCol.set(uniq[i], i);
          const colForPitch = (p)=> pitchToCol.has(p) ? pitchToCol.get(p) : (p % COLS);

          const audioDur = Math.max(0.001, Number(audioBuffer.duration)||0.001);

          for(const n of ranges){
            const startSec = ticksToSeconds(n.startTick, tempoMap, midi.ppq);
            const endSec   = ticksToSeconds(n.endTick, tempoMap, midi.ppq);
            const noteDurSec = Math.max(0.01, endSec - startSec);

            let startStep = Math.floor(startSec / stepDurSec);
            startStep = Math.max(0, Math.min(ROWS-1, startStep));

            const c = colForPitch(n.note);

            gridOn[startStep][c] = true;
            const cell = gridData[startStep][c];

            // Use sample source
            cell.source = "sample";
            cell.hold = false;

            // Slice position in audio: proportional to MIDI timeline (start),
            // but force slice LENGTH to 4 steps (based on current BPM) to avoid clicky micro-slices.
            const startPct = clamp((startSec / maxEndSec) * 100, 0, 100);

            const bpmSnap = Number(bpm) || 120;
            let stepDur = intervalMs(bpmSnap) / 1000; // seconds per step
            if(!Number.isFinite(stepDur) || stepDur <= 0) stepDur = 0.25;
            stepDur = Math.max(0.01, stepDur);

            const sampleDur = (audioBuffer && Number.isFinite(audioBuffer.duration)) ? audioBuffer.duration : 1.0;
            const sliceLenSec = 0.5; // fixed 0.5 second sample length
            const safeSlice = Math.max(0.02, Math.min(sliceLenSec, sampleDur));
            const lenPct = clamp((safeSlice / sampleDur) * 100, 0.01, 100);
            cell.sample = cell.sample || { url:"", name:"", startPct:0, lengthPct:100 };
            cell.sample.url = sampleKey;
            cell.sample.name = audioName || "sample";
            cell.sample.startPct = Number(startPct.toFixed(2));
            cell.sample.lengthPct = Number(lenPct.toFixed(2));

            // Pitch (root → target) + optional duration override
            cell.sample.rootNote = clampInt(rootNote, 0, 127);
            cell.sample.targetNote = clampInt(n.note, 0, 127);
            cell.sample.noteDurSec = Math.max(0.02, (intervalMs((Number(bpm)||120))/1000) * 1); // 1 step playback window
// Give a slightly smoother default envelope for samples
            if(cell.adsr){
              cell.adsr.a = Math.max(CLICK_FADE, Math.min(0.02, cell.adsr.a||0.01));
              cell.adsr.d = Math.max(0.02, cell.adsr.d||0.10);
              cell.adsr.s = clamp(cell.adsr.s ?? 7, 0, 10);
              cell.adsr.r = Math.max(0.05, cell.adsr.r||0.12);
            }
          }

          closeDropdown();
          buildGrid();
          scheduleSave(true);
          setStatus("Sample→MIDI toegepast");
        }
          ERROR.style.display = "none";
            ERROR.textContent = "";

            const buf = await file.arrayBuffer();
            const midi = parseMIDI(buf);
            

            // Remember last loaded MIDI for \"Apply sample to loaded MIDI\"
            window._lastLoadedMidiForS2M = midi;
            try{ s2mUpdateButtons(); }catch{}
midiImportToGrid(midi);
          }catch(e){
            showError(e);
            setStatus("MIDI import failed");
          }
        });

        // ============================================================
        // ========================= WAV EXPORT ========================
        // ============================================================
        document.getElementById("exportWav").addEventListener("click", ()=> exportToWav().catch(showError));

        
document.getElementById("exportWavBpm").addEventListener("click", ()=> exportToWav(true).catch(showError));

document.getElementById("recordLiveWav").addEventListener("click", ()=> recordLiveWav().catch(showError));
async function exportToWav(useCurrentBpm=false){
  const exportBtn = document.getElementById("exportWav");
  exportCancelRequested = false;

  try{
    if(exportBtn) exportBtn.disabled = true;
    exportShow("Export gestart…", 2);
    setStatus("export…");
    await new Promise(r=>setTimeout(r, 20)); // allow UI paint

    // Compute duration in seconds from pattern length (robust)
    const bpmSnap = Number(bpm) || 120;
    let stepDur = intervalMs(bpmSnap) / 1000;
    if(!Number.isFinite(stepDur) || stepDur <= 0) stepDur = 0.25; // fallback
    stepDur = Math.max(0.01, stepDur);

    const rows = (Number.isFinite(ROWS) && ROWS > 0) ? ROWS : 1;
    // Export length = exactly the sequence length at the selected BPM
    const durationSec = Math.max(0.01, rows * stepDur);

    // Offline render
    const sr = (audioCtx && Number.isFinite(audioCtx.sampleRate) && audioCtx.sampleRate > 0) ? audioCtx.sampleRate : 44100;
    exportShow("OfflineAudioContext maken…", 6);
    await new Promise(r=>setTimeout(r, 0));

    const frames = Math.max(1, Math.ceil(durationSec * sr));
    const oac = new OfflineAudioContext(2, frames, sr);

    // Match live master chain (gain + compressor)
    const master = oac.createGain();
    // Same master gain as live (fallback if not available)
    const liveMaster = (typeof masterGain !== "undefined" && masterGain && masterGain.gain) ? masterGain.gain.value : 0.16;
    master.gain.value = liveMaster;

    const comp = oac.createDynamicsCompressor();
    comp.threshold.value = -14;
    comp.knee.value = 18;
    comp.ratio.value = 10;
    comp.attack.value = 0.003;
    comp.release.value = 0.18;

    master.connect(comp);
    comp.connect(oac.destination);

    // Render the sequence into oac
    exportShow("Events plannen…", 10);
    await new Promise(r=>setTimeout(r, 0));

    // Track held notes per column during offline scheduling
    const held = new Map(); // col -> {src, gain, stopAt?}

    function schedStopHold(col, tNow, relSec){
      const v = held.get(col);
      if(!v) return;
      const tEnd = tNow + Math.max(0.0001, relSec);
      try{
        v.gain.gain.cancelScheduledValues(tNow);
        const cur = Math.max(0.00001, v.gain.gain.value || 0.00001);
        v.gain.gain.setValueAtTime(cur, tNow);
        v.gain.gain.exponentialRampToValueAtTime(0.00001, tEnd);
      }catch{}
      try{ v.src.stop(tEnd + STEP_FADE + 0.01); }catch{}
      held.delete(col);
    }

    function schedStartHold(col, cell, t){
      if(held.has(col)) return;

      const src = oac.createOscillator();
      src.type = cell.wave || "sine";
      src.frequency.setValueAtTime(Math.max(1, Number(cell.freq)||440), t);

      const gain = oac.createGain();
      gain.gain.setValueAtTime(0.00001, t);

      // FX chain (same function as live)
      const fxChain = createFXChain(oac, cell.fx, gain);

      // Optional vibrato from cell.fx.type vibpanreverb handled inside createFXChain (detune)
      // If FX chain returns 'out', connect it to master
      (fxChain.out || gain).connect(master);

      // ADSR for hold: attack->decay->sustain (no release yet)
      const A = Math.max(0.00001, getEffectiveADSR(cell).a);
      const D = Math.max(0.00001, getEffectiveADSR(cell).d);
      const S = clamp(getEffectiveADSR(cell).s, 0, 10);
      const peak = 0.28;
      const sustainLevel = Math.max(0.00001, peak * S);

      gain.gain.exponentialRampToValueAtTime(Math.max(0.00001, peak), t + A);
      gain.gain.exponentialRampToValueAtTime(Math.max(0.00001, sustainLevel), t + A + D);
      gain.gain.setValueAtTime(Math.max(0.00001, sustainLevel), t + A + D + 0.0001);

      src.connect(gain);
      src.start(t);

      held.set(col, { src, gain, fxChain });
    }

    function schedOneShot(cell, t, dur){
      const src = oac.createOscillator();
      src.type = cell.wave || "sine";
      src.frequency.setValueAtTime(Math.max(1, Number(cell.freq)||440), t);

      const gain = oac.createGain();
      gain.gain.setValueAtTime(0.00001, t);

      const fxChain = createFXChain(oac, cell.fx, gain);
      (fxChain.out || gain).connect(master);

      src.connect(gain);

      const A_in = Math.max(0, getEffectiveADSR(cell).a);
      const D_in = Math.max(0, getEffectiveADSR(cell).d);
      const S = clamp(Number(cell.adsr?.s)||0, 0, 10);
      const R_in = Math.max(0, getEffectiveADSR(cell).r);

      const stepDur2 = Math.max(0.02, dur);
      const R = Math.max(0.00001, Math.min(stepDur2*0.98, Math.max(0.00001, R_in)));
      const tEnd = t + stepDur2;
      const tRelStart = Math.max(t, tEnd - R);

      const maxAD = Math.max(0.00001, tRelStart - t);
      const A = Math.min(Math.max(0.00001, A_in), maxAD);
      const D = Math.min(Math.max(0.00001, D_in), Math.max(0.00001, maxAD - A));

      const tA = t + A;
      const tD = tA + D;

      const peak = 0.28;
      const sustainLevel = Math.max(0.00001, peak * S);

      gain.gain.exponentialRampToValueAtTime(Math.max(0.00001, peak), tA);
      gain.gain.exponentialRampToValueAtTime(Math.max(0.00001, sustainLevel), tD);
      gain.gain.setValueAtTime(Math.max(0.00001, sustainLevel), tRelStart);
      gain.gain.exponentialRampToValueAtTime(0.00001, tEnd);

      src.start(t);
      src.stop(tEnd + STEP_FADE + 0.01);
    }

    // Schedule each step
    for(let r=0;r<ROWS;r++){
      const t = r * stepDur;
      // progress (based on playback time at current BPM)
      if(r % 32 === 0){
        const tSec = r * stepDur;
        const mm = String(Math.floor(tSec / 60)).padStart(2,"0");
        const ss = String(Math.floor(tSec % 60)).padStart(2,"0");
        exportShow(`Events plannen… ${r}/${ROWS}  (tijd ${mm}:${ss} @ ${fmt2(bpmSnap)} BPM)`, 10 + (40*(r/ROWS)));
        if(exportCancelRequested) throw new Error("Export cancelled");
        // Yield occasionally so UI stays responsive without slowing export too much
        await new Promise(res=>setTimeout(res, 0));
      }

      for(let c=0;c<COLS;c++){
        const isOn = !!gridOn[r][c];
        const cell = gridData[r][c];
        if(!cell) continue;

        const holdKey = c; // per column

        if(isOn){
          if(cell.hold){
            schedStartHold(holdKey, cell, t);
          }else{
            // if hold was active, release it before oneshot
            if(held.has(holdKey)) schedStopHold(holdKey, t, getEffectiveADSR(cell).r);
            schedOneShot(cell, t, stepDur);
          }
        }else{
          // if a hold is active and step turns off: release
          if(held.has(holdKey)) schedStopHold(holdKey, t, getEffectiveADSR(cell).r);
        }
      }
    }

    // Release any still-held voices at the end
    const tEndAll = ROWS * stepDur;
    for(const [col, v] of held.entries()){
      schedStopHold(col, tEndAll, 0.05);
    }

    exportShow("Render audio…", 55);
    await new Promise(r=>setTimeout(r, 20));
    const rendered = await oac.startRendering();

    exportShow("Peak analyse…", 70);
    await new Promise(r=>setTimeout(r, 20));

    // Normalize downward-only to -1 dBFS
    const targetDb = -1.0;
    const targetPeak = Math.pow(10, targetDb / 20);

    let peak = 0;
    const totalCh = rendered.numberOfChannels;
    for (let ch = 0; ch < totalCh; ch++) {
      const data = rendered.getChannelData(ch);
      const N = data.length;
      const chunk = 65536;
      for (let i = 0; i < N; i += chunk) {
        const end = Math.min(N, i + chunk);
        for (let j = i; j < end; j++) {
          const v = Math.abs(data[j]);
          if (v > peak) peak = v;
        }
        exportShow(`Peak analyse… ch ${ch+1}/${totalCh} (${Math.round((end/N)*100)}%)`, 70 + 20*((ch + end/N)/totalCh));
        if(exportCancelRequested) throw new Error("Export cancelled");
        await new Promise(r=>setTimeout(r, 0));
      }
    }

    const gainScale = (peak > targetPeak && peak > 0) ? (targetPeak / peak) : 1;

    exportShow("Encode WAV…", 92);
    await new Promise(r=>setTimeout(r, 20));
    const wavBlob = encodeWavFromBuffer(rendered, gainScale);

    exportShow("Download…", 98);
    await new Promise(r=>setTimeout(r, 20));

    const base = (getLoadedMidiBaseName() || sanitizeFileName(fileNameEl.value));
    const filename = (base.endsWith(".wav") ? base : base + ".wav");

    const url = URL.createObjectURL(wavBlob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);

    exportShow("Klaar!", 100);
    setStatus("wav exported");
    setTimeout(()=>exportHide(), 600);
  }catch(e){
    if(String(e && e.message || e).toLowerCase().includes("cancel")){
      setStatus("cancelled");
    }else{
      showError(e);
      setStatus("export failed");
    }
  }finally{
    try{ if(exportBtn) exportBtn.disabled = false; }catch{}
    if(!exportCancelRequested) setTimeout(()=>exportHide(), 800);
  }
}

        function encodeWavFromBuffer(audioBuffer, gainScale=1){
          const numCh = audioBuffer.numberOfChannels;
          const sr = audioBuffer.sampleRate;
          const length = audioBuffer.length;

          const channels = [];
          for(let ch=0; ch<numCh; ch++){
            channels.push(audioBuffer.getChannelData(ch));
          }

          const interleaved = new Float32Array(length * numCh);
          let idx = 0;
          for(let i=0; i<length; i++){
            for(let ch=0; ch<numCh; ch++){
              interleaved[idx++] = channels[ch][i];
            }
          }

          const pcm = new Int16Array(interleaved.length);
          for(let i=0;i<interleaved.length;i++){
            let s = interleaved[i] * gainScale;
            s = Math.max(-1, Math.min(1, s));
            pcm[i] = (s < 0) ? (s * 0x8000) : (s * 0x7FFF);
          }

          const bytesPerSample = 2;
          const blockAlign = numCh * bytesPerSample;
          const byteRate = sr * blockAlign;
          const dataSize = pcm.length * bytesPerSample;

          const buffer = new ArrayBuffer(44 + dataSize);
          const view = new DataView(buffer);

          function writeStr(off, str){
            for(let i=0;i<str.length;i++) view.setUint8(off+i, str.charCodeAt(i));
          }

          let o = 0;
          writeStr(o, "RIFF"); o += 4;
          view.setUint32(o, 36 + dataSize, true); o += 4;
          writeStr(o, "WAVE"); o += 4;

          writeStr(o, "fmt "); o += 4;
          view.setUint32(o, 16, true); o += 4;
          view.setUint16(o, 1, true); o += 2;
          view.setUint16(o, numCh, true); o += 2;
          view.setUint32(o, sr, true); o += 4;
          view.setUint32(o, byteRate, true); o += 4;
          view.setUint16(o, blockAlign, true); o += 2;
          view.setUint16(o, 16, true); o += 2;

          writeStr(o, "data"); o += 4;
          view.setUint32(o, dataSize, true); o += 4;

          let p = 44;
          for(let i=0;i<pcm.length;i++, p+=2){
            view.setInt16(p, pcm[i], true);
          }

          return new Blob([buffer], { type:"audio/wav" });
        }

        // ---------- build initial grid ----------
        buildGrid();

        // ---------- Save filename autosave also ----------
        try{
          localStorage.setItem(STORAGE_KEY_FILENAME, fileNameEl.value || "");
        }catch{}

        // ---------- READY ----------
        
// ---------- autosave lifecycle hooks ----------
startAutosaveTimer();
window.addEventListener("beforeunload", forceAutosaveNow);
window.addEventListener("pagehide", forceAutosaveNow);
document.addEventListener("visibilitychange", ()=>{
  if(document.visibilityState === "hidden") forceAutosaveNow();
});
// ---------- WAV LIVE EXPORT: robust cancel override ----------
(function(){
  const oldBtn = document.getElementById("recordLiveWav");
  if(!oldBtn) return;

  // Remove any existing listeners by cloning the node
  const btn = oldBtn.cloneNode(true);
  oldBtn.parentNode.replaceChild(btn, oldBtn);

  let rec = null;
  let chunks = [];
  let dest = null;
  let recording = false;
  let stopWatchdog = 0;

  function cleanup(statusMsg){
    try{ if(stopWatchdog){ clearTimeout(stopWatchdog); stopWatchdog = 0; } }catch{}
    try{ if(dest){ masterGain.disconnect(dest); } }catch{}
    try{ if(dest && dest.stream){ dest.stream.getTracks().forEach(t=>{ try{ t.stop(); }catch{} }); } }catch{}
    dest = null;
    rec = null;
    chunks = [];
    recording = false;
    try{ btn.textContent = "Export LIVE WAV"; }catch{}
    if(statusMsg) try{ setStatus(statusMsg); }catch{}
  }

  function pickMime(){
    const cand = ["audio/webm;codecs=opus","audio/webm","audio/ogg;codecs=opus","audio/ogg"];
    for(const c of cand){
      try{ if(MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(c)) return c; }catch{}
    }
    return "";
  }

  async function start(){
    if(recording) return;
    if(!window.MediaRecorder) throw new Error("MediaRecorder not supported");
    if(audioCtx.state==="suspended") await audioCtx.resume();

    chunks = [];
    dest = audioCtx.createMediaStreamDestination();
    masterGain.connect(dest);

    const mime = pickMime();
    rec = new MediaRecorder(dest.stream, mime ? { mimeType: mime } : undefined);

    rec.ondataavailable = (e)=>{ if(e.data && e.data.size) chunks.push(e.data); };

    rec.onerror = (e)=>{ try{ showError(e); }catch{} cleanup("wav error"); };

    rec.onstop = ()=>{
      try{ if(stopWatchdog){ clearTimeout(stopWatchdog); stopWatchdog = 0; } }catch{}
      // Detach
      try{ masterGain.disconnect(dest); }catch{}
      try{ dest.stream.getTracks().forEach(t=>{ try{ t.stop(); }catch{} }); }catch{}
      dest = null;

      const outChunks = chunks.slice();
      chunks = [];
      recording = false;
      try{ btn.textContent = "Export LIVE WAV"; }catch{}

      if(!outChunks.length){
        setStatus("wav cancelled");
        rec = null;
        return;
      }

      const usedMime = rec.mimeType || mime || "audio/webm";
      const blob = new Blob(outChunks, { type: usedMime });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `live_export_${Date.now()}.${usedMime.includes("ogg") ? "ogg" : "webm"}`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(()=>URL.revokeObjectURL(url), 30000);
      setStatus("wav exported");
      rec = null;
    };

    rec.start(250);
    recording = true;
    btn.textContent = "Cancel WAV";
    setStatus("recording wav…");
  }

  function stop(){
    if(!recording){
      return;
    }
    // Watchdog cleanup if onstop never fires (some Android webviews)
    try{ if(stopWatchdog) clearTimeout(stopWatchdog); }catch{}
    stopWatchdog = setTimeout(()=> cleanup("wav cancelled (forced)"), 2000);

    try{
      if(rec && rec.state !== "inactive"){
        try{ rec.requestData(); }catch{}
        rec.stop();
      } else {
        cleanup("wav cancelled");
      }
    }catch{
      cleanup("wav cancelled");
    }
  }

  btn.addEventListener("click", ()=>{
    if(recording) stop();
    else start().catch(showError);
  });

  // If app is backgrounded while recording, stop safely
  document.addEventListener("visibilitychange", ()=>{
    if(document.visibilityState==="hidden" && recording){
      stop();
    }
  });
})();
// ---------- end WAV override ----------




        
// ============================================================
// =============== Algorithmic MIDI Generator UI ===============
// ============================================================
const algoSelectEl = document.getElementById("algoSelect");
const algoLenEl = document.getElementById("algoLengthMs");
const algoVarEl = document.getElementById("algoVar");
const algoVarValEl = document.getElementById("algoVarVal");
const algoDlBtn = document.getElementById("algoDownloadMidi");

// List exactly in the categories + order that we discussed.
const ALGO_CATEGORIES = [
  { name: "1. Deterministische / regel-gebaseerde algoritmes", items: [
    ["scale_loop","Toonladder-loop (up/down/patterns)"],
    ["arpeggiator","Arpeggiators"],
    ["chord_progression","Akkoordprogressie-machines (I–V–vi–IV etc.)"],
    ["euclidean","Euclidische ritmes"],
    ["canon","Canon / fugue-regels"],
    ["voice_leading","Voice-leading optimalisatie"],
    ["counterpoint","Counterpoint-regels"],
    ["polyrhythm","Polyrhythm generators"],
    ["groove_quant","Groove quantization"],
    ["rhythm_tiling","Rhythm tiling"],
    ["motif_transform","Motief-transformatie (invert, retrograde)"],
    ["call_response","Call & response"],
    ["phrase_expand","Phrase expansion"],
    ["ostinato","Ostinato generators"],
    ["harm_rhythm","Harmonic rhythm engines"],
  ]},
  { name: "2. Stochastische / probabilistische algoritmes", items: [
    ["rand_walk","Random walk (pitch / rhythm)"],
    ["weighted_random","Weighted random note choice"],
    ["markov","Markov chains (1e–5e orde)"],
    ["prob_matrix","Probability matrices"],
    ["dice_music","Dice music (Mozart-stijl)"],
    ["density_spawn","Density-based note spawning"],
    ["brownian","Brownian motion"],
    ["stoch_grid","Stochastic rhythm grids"],
    ["cond_prob","Conditional probability rules"],
    ["entropy_limited","Entropy-limited generators"],
    ["mutation","Mutation algorithms"],
    ["drift_harmony","Drift-based harmony"],
    ["prob_voice_alloc","Probabilistic voice allocation"],
    ["timing_jitter","Timing jitter engines"],
    ["prob_swing","Probabilistic swing"],
  ]},
  { name: "3. Evolutionaire & genetische algoritmes", items: [
    ["genetic","Genetic algorithms"],
    ["fitness_melody","Fitness-based melody evolution"],
    ["user_guided","User-guided selection"],
    ["mutate_crossover","Mutation + crossover"],
    ["style_fitness","Style fitness scoring"],
    ["harmony_search","Population harmony search"],
    ["co_evolve","Co-evolving rhythm & pitch"],
    ["constraint_evo","Constraint-based evolution"],
    ["multi_objective","Multi-objective evolution"],
    ["novelty_search","Novelty search"],
  ]},
  { name: "4. AI / Machine-learning", items: [
    ["rnn_like","RNN (LSTM / GRU)"],
    ["transformer_like","Transformer-models"],
    ["diffusion_like","Diffusion-based MIDI"],
    ["vae_like","Variational Autoencoders (VAE)"],
    ["music_lm","Music language models"],
    ["style_transfer","Style-transfer MIDI"],
    ["phrase_embed","Phrase embedding sampling"],
    ["attention_cont","Attention-based continuation"],
    ["token_midi","Token-based MIDI generation"],
    ["latent_interp","Latent space interpolation"],
    ["chord_cond","Chord-conditioned melody"],
    ["rhythm_cond","Rhythm-conditioned harmony"],
    ["prompt_based","Prompt-based generation"],
    ["few_shot","Few-shot MIDI learning"],
    ["humanization","Humanization models"],
  ]},
  { name: "5. Pattern & Grid-based sequencer algoritmes", items: [
    ["step_seq","Step sequencers"],
    ["per_step_prob","Per-step probability"],
    ["ratcheting","Per-step ratcheting"],
    ["conditional_trig","Conditional triggers"],
    ["per_step_mod","Per-step modulation"],
    ["pattern_chain","Pattern chaining"],
    ["pattern_morph","Pattern morphing"],
    ["track_interdep","Track interdependence"],
    ["clock_div_mult","Clock division/multiplication"],
    ["accent_logic","Accent logic"],
    ["velocity_curves","Velocity curves"],
    ["fill_algos","Fill algorithms"],
    ["variation_slots","Variation slots"],
    ["scene_seq","Scene-based sequencing"],
    ["clip_launch","Clip-launch logic"],
  ]},
  { name: "6. Wiskundige / formele systemen", items: [
    ["cellular_auto","Cellular automata"],
    ["l_system","L-systems"],
    ["fractals","Fractals (Mandelbrot / Julia)"],
    ["chaos","Chaos systems (Lorenz)"],
    ["mod_arith","Modular arithmetic music"],
    ["set_theory","Set theory"],
    ["serialism","Serialism (12-tone)"],
    ["graph_walk","Graph-based music"],
    ["constraint_solver","Constraint satisfaction solvers"],
    ["formal_grammar","Formal grammars"],
  ]},
];

function buildAlgoMenu(){
  if(!algoSelectEl) return;
  algoSelectEl.innerHTML = "";
  for(const cat of ALGO_CATEGORIES){
    const og = document.createElement("optgroup");
    og.label = cat.name;
    for(const [id, label] of cat.items){
      const opt = document.createElement("option");
      opt.value = id;
      opt.textContent = label;
      og.appendChild(opt);
    }
    algoSelectEl.appendChild(og);
  }
  // default
  algoSelectEl.value = "scale_loop";
}

function clamp01(x){ x = Number(x); return Math.max(0, Math.min(1, Number.isFinite(x) ? x : 0)); }
function clampInt(x,a,b){ x = (x|0); if(x<a) return a; if(x>b) return b; return x; }
function rndi(a,b){ return (a + Math.floor(Math.random()*(b-a+1))); }
function pick(arr){ return arr[(Math.random()*arr.length)|0]; }
function lerp(a,b,t){ return a + (b-a)*t; }

function scaleNotes(root=60, mode="minor"){
  const maj = [0,2,4,5,7,9,11];
  const min = [0,2,3,5,7,8,10];
  const ints = (mode==="major") ? maj : min;
  const out = [];
  for(let o=-1;o<=1;o++){
    for(const i of ints) out.push(root + i + 12*o);
  }
  return out;
}

function quantTicks(t, q){ return Math.max(0, Math.round(t/q)*q); }

// ---- Tiny MIDI writer (Format 0, single track) ----
function vlq(n){
  n = Math.max(0, n|0);
  let bytes = [n & 0x7F];
  while((n >>= 7) > 0) bytes.unshift((n & 0x7F) | 0x80);
  return bytes;
}

function u32be(n){ return [(n>>>24)&255,(n>>>16)&255,(n>>>8)&255,n&255]; }
function u16be(n){ return [(n>>>8)&255,n&255]; }

function strBytes(s){
  const out = [];
  for(let i=0;i<s.length;i++) out.push(s.charCodeAt(i)&255);
  return out;
}

function makeMidiFile(noteEvents, bpm=120, ppq=480){
  // noteEvents: [{tTick, type:"on"|"off", ch, note, vel}]
  noteEvents.sort((a,b)=> a.tTick - b.tTick || (a.type==="off") - (b.type==="off"));
  const track = [];

  // tempo meta @0
  // delta=0, FF 51 03 tt tt tt
  const usPerQN = Math.round(60000000 / bpm);
  track.push(...vlq(0), 0xFF, 0x51, 0x03, (usPerQN>>16)&255, (usPerQN>>8)&255, usPerQN&255);

  let last = 0;
  for(const e of noteEvents){
    const dt = Math.max(0, (e.tTick|0) - last);
    last = (e.tTick|0);
    track.push(...vlq(dt));
    const ch = Math.max(0, Math.min(15, (e.ch|0)));
    const note = Math.max(0, Math.min(127, (e.note|0)));
    const vel = Math.max(0, Math.min(127, (e.vel|0)));
    if(e.type === "on"){
      track.push(0x90 | ch, note, vel);
    }else{
      track.push(0x80 | ch, note, vel);
    }
  }

  // end of track
  track.push(...vlq(0), 0xFF, 0x2F, 0x00);

  const header = [
    ...strBytes("MThd"),
    ...u32be(6),
    ...u16be(0),      // format 0
    ...u16be(1),      // 1 track
    ...u16be(ppq)     // division
  ];

  const trk = [
    ...strBytes("MTrk"),
    ...u32be(track.length),
    ...track
  ];

  const bytes = new Uint8Array([...header, ...trk]);
  return bytes;
}

function notesToEvents(notes){
  // notes: [{tTick, dTick, note, vel, ch}]
  const ev = [];
  for(const n of notes){
    ev.push({ tTick:n.tTick|0, type:"on", ch:n.ch|0, note:n.note|0, vel:n.vel|0 });
    ev.push({ tTick:(n.tTick + n.dTick)|0, type:"off", ch:n.ch|0, note:n.note|0, vel:0 });
  }
  return ev;
}

// ---- Generators ----
function generateNotes(algoId, lengthMs, variation, bpm=120, ppq=480){
  const stepMs = 125; // ~1/16 at 120bpm (musical grid)
  const steps = Math.max(1, Math.floor(lengthMs / stepMs));
  const ticksPerStep = Math.round((ppq * bpm / 60000) * stepMs); // ticks
  const q = Math.max(1, Math.round(ticksPerStep / 4)); // quantize to 1/64-ish
  const root = 60; // C4
  const scale = scaleNotes(root, (Math.random() < 0.5 ? "minor" : "major"));
  const velBase = 60;
  const velVar = Math.round(lerp(5, 45, variation));

  const notes = [];
  const add = (s, durSteps, p, v=100, ch=0)=>{
    const t = quantTicks(s * ticksPerStep, q);
    const d = Math.max(q, quantTicks(durSteps * ticksPerStep, q));
    notes.push({ tTick:t, dTick:d, note:p, vel:v, ch });
  };

  // helper rhythm decisions
  const prob = (p)=> Math.random() < p;
  const varyP = (base)=> clamp01(base + (Math.random()*2-1)*variation*0.35);

  // ------------------ Deterministic ------------------
  if(algoId==="scale_loop"){
    const dir = prob(0.5) ? 1 : -1;
    const pattern = prob(0.5) ? [0,1,2,3,4,5,6,5,4,3,2,1] : [0,2,4,5,4,2];
    for(let s=0;s<steps;s++){
      const idx = pattern[(dir>0?s:(pattern.length-1-(s%pattern.length))) % pattern.length];
      const p = scale[(idx % scale.length)];
      add(s, 1, p, velBase + rndi(-velVar, velVar));
    }
    return notes;
  }
  if(algoId==="arpeggiator"){
    const chord = [root, root+4, root+7, root+11];
    const pat = [0,1,2,3,2,1];
    for(let s=0;s<steps;s++){
      add(s, 1, chord[pat[s%pat.length]], velBase + rndi(-velVar, velVar));
    }
    return notes;
  }
  if(algoId==="chord_progression"){
    // I–V–vi–IV in C major-ish, then pick chord tones
    const prog = [
      [root, root+4, root+7],
      [root+7, root+11, root+14],
      [root+9, root+12, root+16],
      [root+5, root+9, root+12],
    ];
    const bar = 16;
    for(let s=0;s<steps;s++){
      const chord = prog[Math.floor(s/bar)%prog.length];
      const p = pick(chord);
      const dur = (s%4===0) ? 2 : 1;
      add(s, dur, p, velBase + rndi(-velVar, velVar));
    }
    return notes;
  }
  if(algoId==="euclidean"){
    // Euclidean rhythm: k hits over n steps, mapped to a single pitch + occasional octave
    const n = 16;
    const k = Math.max(1, Math.round(lerp(3, 12, variation)));
    // simple Bjorklund-ish: distribute hits using modular spacing
    for(let s=0;s<steps;s++){
      const hit = ((s * k) % n) < k;
      if(hit){
        const p = root + (prob(variation*0.5)?12:0);
        add(s, 1, p, velBase + 30 + rndi(-velVar, velVar));
      }
    }
    return notes;
  }
  if(algoId==="canon"){
    // Two voices, second enters later (delay) and transposed.
    const delaySteps = 8;
    const melody = [];
    let idx = 0;
    for(let s=0;s<steps;s++){
      const p = scale[idx % scale.length];
      melody.push(p);
      idx += (prob(0.7)?1:2);
      add(s, 1, p, velBase + rndi(-velVar, velVar), 0);
      if(s-delaySteps >= 0){
        const p2 = melody[s-delaySteps] + 7; // fifth
        add(s, 1, p2, velBase + rndi(-velVar, velVar), 1);
      }
    }
    return notes;
  }
  if(algoId==="voice_leading"){
    // Chords changing with minimal motion for top voice
    const chords = [
      [root,root+4,root+7],
      [root+2,root+5,root+9],
      [root+4,root+7,root+11],
      [root+5,root+9,root+12],
    ];
    let lastTop = root+7;
    for(let s=0;s<steps;s+=4){
      const ch = chords[Math.floor((s/4))%chords.length];
      // choose top nearest lastTop among chord tones (plus octaves)
      const candidates = [];
      for(const t of ch){
        candidates.push(t, t+12, t-12);
      }
      candidates.sort((a,b)=>Math.abs(a-lastTop)-Math.abs(b-lastTop));
      lastTop = candidates[0];
      // arpeggiate within 4 steps
      for(let i=0;i<4 && (s+i)<steps;i++){
        add(s+i, 1, candidates[i%3], velBase + rndi(-velVar, velVar));
      }
    }
    return notes;
  }
  if(algoId==="counterpoint"){
    // Cantus firmus + simple counter line (third/sixth preference)
    const cf = [];
    for(let s=0;s<steps;s+=2){
      const p = scale[(s/2)%scale.length];
      cf.push(p);
      add(s, 2, p, velBase + rndi(-velVar, velVar), 0);
      const interval = prob(0.5) ? 3 : 8; // m3 or m6-ish
      const cp = p + interval;
      add(s, 2, cp, velBase + rndi(-velVar, velVar), 1);
    }
    return notes;
  }
  if(algoId==="polyrhythm"){
    // 3:4 over 16 steps
    const p1 = root;
    const p2 = root+7;
    for(let s=0;s<steps;s++){
      if(s%4===0) add(s, 1, p1, velBase+35+rndi(-velVar, velVar), 0);
      if(s%3===0) add(s, 1, p2, velBase+20+rndi(-velVar, velVar), 1);
    }
    return notes;
  }
  if(algoId==="groove_quant"){
    // Straight pattern but with swing-like offset baked in (note-start quant)
    for(let s=0;s<steps;s++){
      if(s%2===0 || prob(0.75)){
        const p = scale[(s*2)%scale.length];
        // emulate groove by shortening odd steps
        const dur = (s%2===1) ? 0.8 : 1;
        add(s, dur, p, velBase + rndi(-velVar, velVar));
      }
    }
    return notes;
  }
  if(algoId==="rhythm_tiling"){
    // Use tiles of lengths 3,5,8
    const tiles = [3,5,8];
    let s=0, pi=0;
    while(s<steps){
      const L = tiles[(pi++)%tiles.length];
      for(let i=0;i<L && s<steps;i++,s++){
        if(i===0 || (i===L-1 && prob(0.6))){
          add(s, 1, scale[(s)%scale.length], velBase+25+rndi(-velVar, velVar));
        }
      }
    }
    return notes;
  }
  if(algoId==="motif_transform"){
    // Motif then invert/retrograde
    const motif = [0,2,4,5,4,2];
    const inv = motif.map(x=> (motif[0] - (x-motif[0])));
    const retro = [...motif].reverse();
    const bank = [motif, inv, retro];
    for(let s=0;s<steps;s++){
      const phrase = bank[Math.floor((s/16))%bank.length];
      const idx = phrase[s%phrase.length];
      const p = root + idx;
      add(s, 1, p, velBase + rndi(-velVar, velVar));
    }
    return notes;
  }
  if(algoId==="call_response"){
    for(let s=0;s<steps;s++){
      const isCall = (Math.floor(s/8)%2===0);
      const p = isCall ? (scale[(s)%scale.length]) : (scale[(s+3)%scale.length]+12);
      const v = velBase + (isCall?25:10) + rndi(-velVar, velVar);
      add(s, 1, p, v);
    }
    return notes;
  }
  if(algoId==="phrase_expand"){
    // start with sparse, then denser
    for(let s=0;s<steps;s++){
      const t = s/steps;
      const pHit = lerp(0.25, 0.95, t) * (0.7 + 0.6*variation);
      if(prob(pHit)){
        add(s, prob(0.2)?2:1, scale[(s*3)%scale.length], velBase+20+rndi(-velVar, velVar));
      }
    }
    return notes;
  }
  if(algoId==="ostinato"){
    const ost = [root, root+7, root+5, root+7];
    for(let s=0;s<steps;s++){
      add(s, 1, ost[s%ost.length], velBase+20+rndi(-velVar, velVar));
      if(prob(0.15 + variation*0.4)) add(s, 1, root+12, velBase+10+rndi(-velVar, velVar));
    }
    return notes;
  }
  if(algoId==="harm_rhythm"){
    // change harmony slower than melody
    const roots = [root, root+7, root+9, root+5];
    for(let s=0;s<steps;s++){
      const r = roots[Math.floor(s/16)%roots.length];
      const chord = [r, r+4, r+7];
      add(s, 1, pick(chord), velBase+20+rndi(-velVar, velVar));
    }
    return notes;
  }

  // ------------------ Stochastic ------------------
  if(algoId==="rand_walk"){
    let pos = rndi(0, scale.length-1);
    for(let s=0;s<steps;s++){
      pos += rndi(-1,1);
      pos = Math.max(0, Math.min(scale.length-1, pos));
      const p = scale[pos] + (prob(variation*0.3)?12:0);
      add(s, 1, p, velBase+15+rndi(-velVar, velVar));
    }
    return notes;
  }
  if(algoId==="weighted_random"){
    // prefer chord tones of I chord
    const chord = new Set([root,root+4,root+7,root+12,root+16,root+19]);
    for(let s=0;s<steps;s++){
      const cand = pick(scale);
      const w = chord.has(cand) ? 0.8 : 0.2;
      if(prob(lerp(0.35,0.95,variation)*w + 0.1)){
        add(s, prob(0.15)?2:1, cand, velBase+20+rndi(-velVar, velVar));
      }
    }
    return notes;
  }
  if(algoId==="markov"){
    // tiny markov over scale degrees
    const N = 7;
    let st = rndi(0,N-1);
    // transition biased to stepwise motion
    const trans = Array.from({length:N}, (_,i)=> Array.from({length:N}, (_,j)=> {
      const d = Math.abs(i-j);
      return 1 / (1 + d*d);
    }));
    const pickNext = (i)=>{
      const row = trans[i];
      const sum = row.reduce((a,b)=>a+b,0);
      let x = Math.random()*sum;
      for(let j=0;j<row.length;j++){
        x -= row[j];
        if(x<=0) return j;
      }
      return row.length-1;
    };
    for(let s=0;s<steps;s++){
      const p = scale[st % scale.length];
      if(prob(0.8)) add(s, 1, p, velBase+18+rndi(-velVar, velVar));
      st = pickNext(st);
      if(prob(variation*0.2)) st = rndi(0,N-1);
    }
    return notes;
  }
  if(algoId==="prob_matrix"){
    // 2D prob: time->pitch band
    for(let s=0;s<steps;s++){
      const t = s/steps;
      const center = Math.floor(lerp(0, scale.length-1, t));
      const spread = Math.max(1, Math.round(lerp(1, 4, variation)));
      const idx = clampInt(center + rndi(-spread, spread), 0, scale.length-1);
      if(prob(lerp(0.35,0.9,variation))) add(s, 1, scale[idx], velBase+15+rndi(-velVar, velVar));
    }
    return notes;
  }
  if(algoId==="dice_music"){
    // "Dice" chooses bars and turns into arpeggio patterns
    const patterns = [
      [0,2,4,2],
      [0,4,7,4],
      [0,3,5,7],
      [0,5,4,2],
      [0,7,5,4],
      [0,2,5,9],
    ];
    for(let s=0;s<steps;s++){
      const bar = Math.floor(s/16);
      const pat = patterns[(bar + rndi(0,5))%patterns.length];
      const p = root + pat[s%pat.length];
      if(prob(0.7)) add(s, 1, p, velBase+20+rndi(-velVar, velVar));
    }
    return notes;
  }
  if(algoId==="density_spawn"){
    for(let s=0;s<steps;s++){
      const dens = lerp(0.15, 0.98, variation);
      if(prob(dens)){
        add(s, prob(0.25)?2:1, pick(scale), velBase+10+rndi(-velVar, velVar));
      }
    }
    return notes;
  }
  if(algoId==="brownian"){
    // slower random walk
    let pos = rndi(0, scale.length-1);
    for(let s=0;s<steps;s++){
      if(prob(0.35 + 0.4*variation)) pos += rndi(-1,1);
      pos = clampInt(pos,0,scale.length-1);
      if(prob(0.65)) add(s, 1, scale[pos], velBase+12+rndi(-velVar, velVar));
    }
    return notes;
  }
  if(algoId==="stoch_grid"){
    // random rhythm grid with constrained density
    const dens = lerp(0.2, 0.75, variation);
    for(let s=0;s<steps;s++){
      if(prob(dens)){
        const dur = prob(0.2+0.6*variation) ? 2 : 1;
        add(s, dur, scale[(s*5)%scale.length], velBase+15+rndi(-velVar, velVar));
      }
    }
    return notes;
  }
  if(algoId==="cond_prob"){
    // If last was high note, next likely down etc.
    let last = root;
    for(let s=0;s<steps;s++){
      const upProb = last < root ? 0.7 : 0.3;
      const step = prob(upProb) ? 1 : -1;
      const candidates = scale.slice().sort((a,b)=>a-b);
      let idx = candidates.findIndex(x=>x>=last);
      if(idx<0) idx = candidates.length-1;
      idx = clampInt(idx + step, 0, candidates.length-1);
      const p = candidates[idx];
      last = p;
      if(prob(0.75)) add(s, 1, p, velBase+15+rndi(-velVar, velVar));
    }
    return notes;
  }
  if(algoId==="entropy_limited"){
    // limit pitch choices based on variation (lower variation -> fewer notes)
    const k = Math.max(3, Math.round(lerp(3, scale.length, variation)));
    const pool = scale.slice(0,k);
    for(let s=0;s<steps;s++){
      if(prob(0.8)) add(s, 1, pick(pool), velBase+12+rndi(-velVar, velVar));
    }
    return notes;
  }
  if(algoId==="mutation"){
    // start motif then mutate occasionally
    let motif = [0,2,4,5,7,5,4,2].map(x=>root+x);
    for(let s=0;s<steps;s++){
      if(prob(variation*0.15)){
        const i = rndi(0,motif.length-1);
        motif[i] += pick([-2,-1,1,2]);
      }
      add(s, 1, motif[s%motif.length], velBase+15+rndi(-velVar, velVar));
    }
    return notes;
  }
  if(algoId==="drift_harmony"){
    // root drifts over time
    let r = root;
    for(let s=0;s<steps;s++){
      if(s%16===0 && prob(0.8)) r += pick([-2,-1,1,2]) * (prob(variation)?1:0);
      const chord = [r, r+4, r+7];
      if(prob(0.8)) add(s, 1, pick(chord), velBase+18+rndi(-velVar, velVar));
    }
    return notes;
  }
  if(algoId==="prob_voice_alloc"){
    // two voices compete
    for(let s=0;s<steps;s++){
      if(prob(0.65)) add(s, 1, pick(scale), velBase+12+rndi(-velVar, velVar), prob(0.5)?0:1);
    }
    return notes;
  }
  if(algoId==="timing_jitter"){
    // create note times with jitter by slightly shifting tick start
    for(let s=0;s<steps;s++){
      if(prob(0.8)){
        const t = s * ticksPerStep;
        const jitter = Math.round((Math.random()*2-1) * variation * (ticksPerStep*0.18));
        const tt = quantTicks(t + jitter, q);
        notes.push({ tTick:tt, dTick:quantTicks(1*ticksPerStep, q), note:pick(scale), vel:velBase+15+rndi(-velVar, velVar), ch:0 });
      }
    }
    return notes;
  }
  if(algoId==="prob_swing"){
    // swing: delay off-beats
    for(let s=0;s<steps;s++){
      if(prob(0.75)){
        const t = s * ticksPerStep;
        const isOff = (s%2===1);
        const swing = isOff ? Math.round(variation * ticksPerStep * 0.33) : 0;
        const tt = quantTicks(t + swing, q);
        notes.push({ tTick:tt, dTick:quantTicks(1*ticksPerStep, q), note:scale[(s*2)%scale.length], vel:velBase+15+rndi(-velVar, velVar), ch:0 });
      }
    }
    return notes;
  }

  // ------------------ Evolutionary / Genetic ------------------
  function fitness(mel){
    // Simple: reward scale tones and smaller intervals, penalize jumps.
    let f = 0;
    for(let i=1;i<mel.length;i++){
      const d = Math.abs(mel[i]-mel[i-1]);
      f += (d<=2?2:(d<=5?1:-1));
    }
    return f;
  }
  function mutateMel(mel, rate){
    const out = mel.slice();
    for(let i=0;i<out.length;i++){
      if(prob(rate)){
        out[i] = pick(scale) + (prob(variation*0.3)?12:0);
      }
    }
    return out;
  }
  if(["genetic","fitness_melody","user_guided","mutate_crossover","style_fitness","harmony_search","co_evolve","constraint_evo","multi_objective","novelty_search"].includes(algoId)){
    const L = Math.min(64, steps);
    let pop = Array.from({length: 12}, ()=> Array.from({length:L}, ()=> pick(scale)));
    const gens = 12;
    for(let g=0; g<gens; g++){
      const scored = pop.map(m=>({m, f: fitness(m)})).sort((a,b)=>b.f-a.f);
      const elites = scored.slice(0,4).map(x=>x.m);
      const next = elites.slice();
      while(next.length < pop.length){
        const a = pick(elites), b = pick(elites);
        const cut = rndi(4, L-4);
        const child = a.slice(0,cut).concat(b.slice(cut));
        const mutRate = lerp(0.02, 0.25, variation);
        next.push(mutateMel(child, mutRate));
      }
      pop = next;
    }
    const best = pop.map(m=>({m, f: fitness(m)})).sort((a,b)=>b.f-a.f)[0].m;
    for(let s=0;s<steps;s++){
      const p = best[s%best.length];
      const dur = prob(0.2+0.4*variation)?2:1;
      if(prob(0.85)) add(s, dur, p, velBase+18+rndi(-velVar, velVar));
    }
    return notes;
  }

  // ------------------ AI / ML (lightweight "stand-ins") ------------------
  if(algoId==="rnn_like"){
    // recurrent: previous note influences next strongly
    let cur = pick(scale);
    for(let s=0;s<steps;s++){
      if(prob(0.9)) add(s, 1, cur, velBase+15+rndi(-velVar, velVar));
      const move = pick([-2,-1,0,1,2,3,-3]);
      // biased to stay near previous
      const pool = scale.slice().sort((a,b)=>Math.abs((a)-(cur+move))-Math.abs((b)-(cur+move)));
      cur = pool[0];
      if(prob(variation*0.25)) cur = pick(scale);
    }
    return notes;
  }
  if(algoId==="transformer_like"){
    // attention-ish: reuse earlier motifs with jumps to previous bars
    const mem = [];
    for(let s=0;s<steps;s++){
      let p;
      if(mem.length>0 && prob(0.55 + 0.35*variation)){
        const lookback = rndi(1, Math.min(48, mem.length));
        p = mem[mem.length - lookback];
        if(prob(variation*0.3)) p += pick([-12,0,12]);
      }else{
        p = pick(scale);
      }
      mem.push(p);
      add(s, prob(0.15)?2:1, p, velBase+15+rndi(-velVar, velVar));
    }
    return notes;
  }
  if(algoId==="diffusion_like"){
    // start random, then progressively smooth (denoise)
    let seq = Array.from({length: steps}, ()=> pick(scale));
    const passes = 6 + Math.round(variation*8);
    for(let p=0;p<passes;p++){
      const next = seq.slice();
      for(let i=1;i<seq.length-1;i++){
        if(prob(0.65)){
          // pull toward neighbors
          const a = seq[i-1], b = seq[i+1];
          next[i] = (Math.abs(a-seq[i]) < Math.abs(b-seq[i])) ? a : b;
        }
      }
      seq = next;
    }
    for(let s=0;s<steps;s++){
      if(prob(0.8)) add(s, 1, seq[s], velBase+12+rndi(-velVar, velVar));
    }
    return notes;
  }
  if(algoId==="vae_like"){
    // latent interpolation between two motifs
    const A = Array.from({length: 16}, ()=> pick(scale));
    const B = Array.from({length: 16}, ()=> pick(scale));
    for(let s=0;s<steps;s++){
      const t = (s%64)/63;
      const i = s%16;
      const p = Math.round(lerp(A[i], B[i], t));
      add(s, 1, p, velBase+14+rndi(-velVar, velVar));
    }
    return notes;
  }
  if(algoId==="music_lm" || algoId==="token_midi" || algoId==="attention_cont"){
    // n-gram token model
    const vocab = scale.slice();
    const hist = [pick(vocab), pick(vocab)];
    for(let s=0;s<steps;s++){
      const key = (hist[0]%12) + "," + (hist[1]%12);
      // simple conditional
      const cand = vocab.slice().sort((a,b)=> Math.abs((a%12) - hist[1]%12) - Math.abs((b%12)-hist[1]%12));
      const p = prob(0.7+0.2*variation) ? cand[rndi(0, Math.min(3, cand.length-1))] : pick(vocab);
      add(s, 1, p, velBase+13+rndi(-velVar, velVar));
      hist.shift(); hist.push(p);
    }
    return notes;
  }
  if(algoId==="style_transfer" || algoId==="chord_cond" || algoId==="rhythm_cond" || algoId==="phrase_embed" || algoId==="latent_interp" || algoId==="prompt_based" || algoId==="few_shot"){
    // "conditioning": fixed groove + harmony pool
    const chords = [
      [root,root+4,root+7],
      [root+7,root+11,root+14],
      [root+9,root+12,root+16],
      [root+5,root+9,root+12],
    ];
    for(let s=0;s<steps;s++){
      const chord = chords[Math.floor(s/16)%chords.length];
      const hit = (s%4===0) || prob(0.25 + 0.6*variation);
      if(hit){
        const p = prob(0.65) ? pick(chord) : pick(scale);
        const dur = (s%8===0) ? 2 : 1;
        add(s, dur, p, velBase+18+rndi(-velVar, velVar));
      }
    }
    return notes;
  }
  if(algoId==="humanization"){
    // strong velocity + microtiming humanize
    for(let s=0;s<steps;s++){
      if(prob(0.8)){
        const t = s * ticksPerStep;
        const jitter = Math.round((Math.random()*2-1) * (0.08+0.18*variation) * ticksPerStep);
        const vel = clampInt(70 + rndi(-40,40), 1, 127);
        notes.push({ tTick:quantTicks(t+jitter, q), dTick:quantTicks(ticksPerStep*(prob(0.2)?2:1), q), note:pick(scale), vel, ch:0 });
      }
    }
    return notes;
  }

  // ------------------ Sequencer style ------------------
  if(algoId==="step_seq"){
    const pattern = [1,0,0,1, 0,1,0,0, 1,0,1,0, 0,0,1,0];
    for(let s=0;s<steps;s++){
      if(pattern[s%pattern.length]){
        add(s, 1, scale[(s*2)%scale.length], velBase+25+rndi(-velVar, velVar));
      }
    }
    return notes;
  }
  if(algoId==="per_step_prob"){
    for(let s=0;s<steps;s++){
      const pHit = lerp(0.15, 0.95, variation);
      if(prob(pHit)){
        add(s, 1, pick(scale), velBase+18+rndi(-velVar, velVar));
      }
    }
    return notes;
  }
  if(algoId==="ratcheting"){
    // bursts on some steps
    for(let s=0;s<steps;s++){
      if(prob(0.35 + 0.4*variation)){
        const rat = prob(0.5) ? 2 : 4;
        for(let k=0;k<rat;k++){
          const t = s*ticksPerStep + Math.round(k*(ticksPerStep/rat));
          notes.push({ tTick:quantTicks(t, q), dTick:quantTicks(Math.round(ticksPerStep/rat), q), note:pick(scale), vel:velBase+18+rndi(-velVar, velVar), ch:0 });
        }
      }
    }
    return notes;
  }
  if(algoId==="conditional_trig"){
    let lastHit = false;
    for(let s=0;s<steps;s++){
      const cond = lastHit ? (0.25 + 0.5*variation) : (0.65);
      const hit = prob(cond);
      lastHit = hit;
      if(hit) add(s, 1, pick(scale), velBase+18+rndi(-velVar, velVar));
    }
    return notes;
  }
  if(algoId==="per_step_mod"){
    // map step->cc-like velocity curve (as proxy)
    for(let s=0;s<steps;s++){
      const t = s/steps;
      const v = clampInt(30 + Math.round(90*(0.5+0.5*Math.sin(2*Math.PI*(2*t + variation)))), 1, 127);
      if(prob(0.8)) add(s, 1, scale[(s)%scale.length], v);
    }
    return notes;
  }
  if(algoId==="pattern_chain" || algoId==="variation_slots" || algoId==="scene_seq" || algoId==="clip_launch"){
    // chain patterns A/B/C/D
    const pats = [
      [1,0,1,0, 0,1,0,0, 1,0,0,1, 0,0,1,0],
      [1,0,0,1, 1,0,0,1, 0,1,0,0, 0,1,0,0],
      [1,1,0,0, 1,0,1,0, 0,1,0,1, 0,0,1,0],
      [1,0,0,0, 1,0,0,0, 1,0,1,0, 0,0,1,0],
    ];
    for(let s=0;s<steps;s++){
      const pat = pats[Math.floor(s/16)%pats.length];
      if(pat[s%16]){
        add(s, 1, scale[(s*3)%scale.length], velBase+22+rndi(-velVar, velVar));
      }
    }
    return notes;
  }
  if(algoId==="pattern_morph"){
    // morph between 2 patterns by probability
    const A = [1,0,1,0, 0,1,0,0, 1,0,0,1, 0,0,1,0];
    const B = [1,0,0,1, 0,1,1,0, 1,0,1,0, 0,1,0,0];
    for(let s=0;s<steps;s++){
      const t = s/steps;
      const useB = prob(t*variation);
      const on = (useB ? B : A)[s%16];
      if(on) add(s, 1, pick(scale), velBase+22+rndi(-velVar, velVar));
    }
    return notes;
  }
  if(algoId==="track_interdep"){
    // bass + lead with dependency
    for(let s=0;s<steps;s++){
      if(s%4===0) add(s, 2, root-12, velBase+30+rndi(-velVar, velVar), 0);
      if(prob(0.6)) add(s, 1, scale[(s*2)%scale.length]+12, velBase+10+rndi(-velVar, velVar), 1);
    }
    return notes;
  }
  if(algoId==="clock_div_mult"){
    for(let s=0;s<steps;s++){
      if(s%4===0) add(s, 1, root, velBase+25+rndi(-velVar, velVar), 0);
      if(s%2===0 && prob(0.7)) add(s, 1, root+7, velBase+15+rndi(-velVar, velVar), 1);
    }
    return notes;
  }
  if(algoId==="accent_logic" || algoId==="velocity_curves" || algoId==="fill_algos"){
    for(let s=0;s<steps;s++){
      const isAccent = (s%4===0);
      const v = clampInt((isAccent?105:70) + rndi(-velVar, velVar), 1, 127);
      if(prob(isAccent ? 0.95 : (0.55 + 0.3*variation))){
        add(s, 1, scale[(s)%scale.length], v);
      }
      // occasional fill at end of bars
      if(algoId==="fill_algos" && (s%16>=12) && prob(0.25+0.5*variation)){
        add(s, 1, scale[(s*3)%scale.length]+12, clampInt(v+10,1,127));
      }
    }
    return notes;
  }

  // ------------------ Math / Formal ------------------
  if(algoId==="cellular_auto"){
    // elementary CA rule 30 on 16 cells, map active cells to notes
    const rule = 30;
    let cells = Array.from({length:16}, (_,i)=> i===8 ? 1 : 0);
    const mapPitch = (i)=> root + (i%8)*2;
    for(let s=0;s<steps;s++){
      for(let i=0;i<cells.length;i++){
        if(cells[i]) add(s, 1, mapPitch(i), velBase+12+rndi(-velVar, velVar));
      }
      const next = cells.slice();
      for(let i=0;i<cells.length;i++){
        const l = cells[(i-1+cells.length)%cells.length];
        const c = cells[i];
        const r = cells[(i+1)%cells.length];
        const idx = (l<<2)|(c<<1)|r;
        next[i] = (rule >> idx) & 1;
      }
      cells = next;
    }
    return notes;
  }
  if(algoId==="l_system"){
    // simple L-system (A->AB, B->A) produce up/down steps
    let seq = "A";
    const iters = 6 + Math.round(variation*4);
    for(let i=0;i<iters;i++){
      seq = seq.replace(/A/g,"x").replace(/B/g,"A").replace(/x/g,"AB");
    }
    let pos = 0;
    for(let s=0;s<steps;s++){
      const ch = seq[s%seq.length];
      pos += (ch==="A") ? 1 : -1;
      pos = clampInt(pos,0,scale.length-1);
      add(s, 1, scale[pos], velBase+12+rndi(-velVar, velVar));
    }
    return notes;
  }
  if(algoId==="fractals"){
    // use fractional part of logistic map to pick notes
    let x = 0.1234;
    const r = 3.6 + 0.35*variation;
    for(let s=0;s<steps;s++){
      x = r * x * (1-x);
      const idx = Math.floor((x % 1) * scale.length);
      if(prob(0.75)) add(s, 1, scale[clampInt(idx,0,scale.length-1)], velBase+12+rndi(-velVar, velVar));
    }
    return notes;
  }
  if(algoId==="chaos"){
    // lorenz-ish (very simplified discrete) -> pitch
    let x=0.1,y=0,z=0;
    const a=10,b=28,c=8/3;
    const dt = 0.01 + 0.02*variation;
    for(let s=0;s<steps;s++){
      const dx = a*(y-x);
      const dy = x*(b-z)-y;
      const dz = x*y - c*z;
      x += dx*dt; y += dy*dt; z += dz*dt;
      const v = Math.abs(x + y + z);
      const idx = clampInt(Math.floor((v*3) % scale.length), 0, scale.length-1);
      if(prob(0.7)) add(s, 1, scale[idx], velBase+12+rndi(-velVar, velVar));
    }
    return notes;
  }
  if(algoId==="mod_arith"){
    // modular arithmetic sequence
    const m = 13;
    const a = 5, b = 3;
    let v=1;
    for(let s=0;s<steps;s++){
      v = (a*v + b) % m;
      const idx = v % scale.length;
      add(s, 1, scale[idx], velBase+12+rndi(-velVar, velVar));
    }
    return notes;
  }
  if(algoId==="set_theory"){
    // pitch class set -> transpositions
    const pcs = [0,1,4,6,7,10];
    for(let s=0;s<steps;s++){
      const tr = (Math.floor(s/8)*2) % 12;
      const p = root + tr + pick(pcs);
      if(prob(0.8)) add(s, 1, p, velBase+12+rndi(-velVar, velVar));
    }
    return notes;
  }
  if(algoId==="serialism"){
    // 12-tone row
    const row = Array.from({length:12}, (_,i)=>i);
    for(let i=row.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; const t=row[i]; row[i]=row[j]; row[j]=t; }
    for(let s=0;s<steps;s++){
      const pc = row[s%row.length];
      add(s, 1, root + pc, velBase+12+rndi(-velVar, velVar));
    }
    return notes;
  }
  if(algoId==="graph_walk"){
    // random walk on a small graph of pitch nodes
    const nodes = scale.slice(0,8);
    const edges = nodes.map((_,i)=> {
      const nbr = [];
      for(const d of [1,2,3]){ nbr.push((i+d)%nodes.length, (i-d+nodes.length)%nodes.length); }
      return Array.from(new Set(nbr));
    });
    let i = rndi(0,nodes.length-1);
    for(let s=0;s<steps;s++){
      add(s, 1, nodes[i], velBase+12+rndi(-velVar, velVar));
      i = pick(edges[i]);
      if(prob(variation*0.2)) i = rndi(0,nodes.length-1);
    }
    return notes;
  }
  if(algoId==="constraint_solver"){
    // simple backtracking: avoid repeats and big jumps
    const L = Math.min(64, steps);
    const out = [];
    const maxJump = Math.round(lerp(2, 8, variation));
    function ok(prev, cand){
      if(prev==null) return true;
      if(cand===prev) return false;
      return Math.abs(cand-prev) <= maxJump;
    }
    function backtrack(i, prev){
      if(i>=L) return true;
      const pool = scale.slice().sort(()=>Math.random()-0.5);
      for(const cand of pool){
        if(ok(prev,cand)){
          out[i]=cand;
          if(backtrack(i+1, cand)) return true;
        }
      }
      return false;
    }
    backtrack(0, null);
    for(let s=0;s<steps;s++){
      const p = out[s%out.length] ?? pick(scale);
      if(prob(0.85)) add(s, 1, p, velBase+12+rndi(-velVar, velVar));
    }
    return notes;
  }
  if(algoId==="formal_grammar"){
    // simple grammar: S->AB, A->aA|a, B->bB|b, map a/b to step directions
    let str = "S";
    for(let i=0;i<8+Math.round(variation*6);i++){
      str = str.replace("S","AB");
      str = str.replace(/A/g, ()=> (prob(0.5) ? "aA" : "a"));
      str = str.replace(/B/g, ()=> (prob(0.5) ? "bB" : "b"));
      if(str.length > 256) break;
    }
    let pos = rndi(0,scale.length-1);
    for(let s=0;s<steps;s++){
      const ch = str[s%str.length];
      pos += (ch==="a") ? 1 : -1;
      pos = clampInt(pos,0,scale.length-1);
      add(s, 1, scale[pos], velBase+12+rndi(-velVar, velVar));
    }
    return notes;
  }

  // fallback
  for(let s=0;s<steps;s++){
    if(prob(0.75)) add(s, 1, pick(scale), velBase+12+rndi(-velVar, velVar));
  }
  return notes;
}

function algoDownload(){
  try{
    const algoId = algoSelectEl ? algoSelectEl.value : "scale_loop";
    const lengthMs = Math.max(10, Number(algoLenEl?.value)||30000);
    const variation = clamp01(algoVarEl?.value ?? 0.35);

    const bpm = 120;
    const ppq = 480;

    const notes = generateNotes(algoId, lengthMs, variation, bpm, ppq);
    const bytes = makeMidiFile(notesToEvents(notes), bpm, ppq);

    const blob = new Blob([bytes], { type: "audio/midi" });
    const url = URL.createObjectURL(blob);

    const base = sanitizeFileName((fileNameEl && fileNameEl.value) ? fileNameEl.value : "generated");
    const safeAlgo = sanitizeFileName(algoId);
    const a = document.createElement("a");
    a.href = url;
    a.download = `${base}_${safeAlgo}_${Math.round(lengthMs)}ms.mid`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 30000);

    setStatus("midi downloaded");
  }catch(e){
    showError(e);
  }
}

if(algoVarEl && algoVarValEl){
  const upd = ()=>{ algoVarValEl.textContent = (Number(algoVarEl.value)||0).toFixed(2); };
  algoVarEl.addEventListener("input", upd);
  upd();
}
if(algoDlBtn) algoDlBtn.addEventListener("click", algoDownload);

buildAlgoMenu();
// ============================================================
// ============= end Algorithmic MIDI Generator UI =============
// ============================================================


        setStatus("ready");
      })();
    </script>
  
  <canvas id="freqCanvas" width="960" height="540" style="display:none;"></canvas>

</body>
</html>